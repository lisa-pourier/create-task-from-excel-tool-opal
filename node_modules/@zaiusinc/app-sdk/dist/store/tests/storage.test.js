"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const async_hooks_1 = require("async_hooks");
require("jest");
const __1 = require("..");
const LocalStore_1 = require("../LocalStore");
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
class SampleStore {
}
describe('storage', () => {
    function runWithAsyncLocalStore(code) {
        const ocpContextStorage = new async_hooks_1.AsyncLocalStorage();
        global.ocpContextStorage = ocpContextStorage;
        const context = {
            ocpRuntime: {
                appContext: {},
                functionApi: {},
                jobApi: {},
                logContext: {},
                logLevel: {},
                notifier: {},
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                secretsStore: new SampleStore(),
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                settingsStore: new SampleStore(),
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                kvStore: new SampleStore(),
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                sharedKvStore: new SampleStore()
            }
        };
        ocpContextStorage.run(context, code);
    }
    it('provides local stores if not configured', () => {
        expect(__1.storage.secrets).toBeInstanceOf(LocalStore_1.LocalStore);
        expect(__1.storage.settings).toBeInstanceOf(LocalStore_1.LocalStore);
        expect(__1.storage.kvStore).toBeInstanceOf(__1.LocalKVStore);
        expect(__1.storage.sharedKvStore).toBeInstanceOf(__1.LocalKVStore);
    });
    describe('stores configuration from async local storage', () => {
        it('uses stores provided in OCP runtime global variable', () => {
            runWithAsyncLocalStore(() => {
                expect(__1.storage.secrets).toBeInstanceOf(SampleStore);
                expect(__1.storage.settings).toBeInstanceOf(SampleStore);
                expect(__1.storage.kvStore).toBeInstanceOf(SampleStore);
                expect(__1.storage.sharedKvStore).toBeInstanceOf(SampleStore);
            });
        });
    });
    describe('resetLocalStores', () => {
        it('resets local stores', async () => {
            await __1.storage.secrets.put('foo', { foo: 'foo' });
            await __1.storage.settings.put('foo', { foo: 'foo' });
            await __1.storage.kvStore.put('foo', { foo: 'foo' });
            (0, __1.resetLocalStores)();
            expect(await __1.storage.secrets.get('foo')).toEqual({});
            expect(await __1.storage.settings.get('foo')).toEqual({});
            expect(await __1.storage.kvStore.get('foo')).toEqual({});
        });
    });
    describe('initializeStores in module scope', () => {
        it('replaces the local stores with the provided stores', () => {
            (0, __1.initializeStores)({
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                secrets: new SampleStore(),
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                settings: new SampleStore(),
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                kvStore: new SampleStore()
            });
            expect(__1.storage.secrets).toBeInstanceOf(SampleStore);
            expect(__1.storage.settings).toBeInstanceOf(SampleStore);
            expect(__1.storage.kvStore).toBeInstanceOf(SampleStore);
        });
        it('throws errors if you try to reset a non-local store', () => {
            expect(() => (0, __1.resetLocalSecretsStore)()).toThrow();
            expect(() => (0, __1.resetLocalSettingsStore)()).toThrow();
            expect(() => (0, __1.resetLocalKvStore)()).toThrow();
        });
    });
});
//# sourceMappingURL=storage.test.js.map