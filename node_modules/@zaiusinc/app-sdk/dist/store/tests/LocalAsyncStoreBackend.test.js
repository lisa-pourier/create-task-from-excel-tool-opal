"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("jest");
const CasError_1 = require("../CasError");
const LocalAsyncStoreBackend_1 = require("../LocalAsyncStoreBackend");
/**
 * Mostly exercised through LocalKVStore tests, but here we test some of the nuances we skipped over
 */
describe('LocalAsyncStoreBackend', () => {
    let store;
    beforeEach(() => {
        jest.spyOn(LocalAsyncStoreBackend_1.LocalAsyncStoreBackend.prototype, 'epoch').mockReturnValue(1585273000);
        store = new LocalAsyncStoreBackend_1.LocalAsyncStoreBackend(0, { foo: { cas: 1, expires: 1585273000 + 500, value: { bar: 'bar' } } });
    });
    describe('get', () => {
        it('retrives existing values and metadata', async () => {
            expect(await store.get('foo')).toEqual({
                cas: 1,
                ttl: 500,
                value: {
                    bar: 'bar'
                }
            });
        });
        it('returns {} for expired values', async () => {
            jest.spyOn(LocalAsyncStoreBackend_1.LocalAsyncStoreBackend.prototype, 'epoch').mockReturnValue(1585273500);
            expect(await store.get('foo')).toEqual({
                cas: 1,
                ttl: 0,
                value: {
                    bar: 'bar'
                }
            });
            jest.spyOn(LocalAsyncStoreBackend_1.LocalAsyncStoreBackend.prototype, 'epoch').mockReturnValue(1585273501);
            expect(await store.get('foo')).toEqual({
                cas: 0,
                value: {}
            });
        });
    });
    describe('put', () => {
        it('writes new values', async () => {
            const changeFn = jest.spyOn(store, 'onChange');
            await store.put('bar', { bar: 'bar' });
            expect(await store.get('bar')).toEqual({
                cas: 0,
                value: {
                    bar: 'bar'
                }
            });
            await store.put('baz', { baz: 'baz' }, 600, 3);
            expect(await store.get('baz')).toEqual({
                cas: 3,
                ttl: 600,
                value: {
                    baz: 'baz'
                }
            });
            expect(changeFn).toHaveBeenCalledTimes(2);
        });
        it('overwrites values if the cas matches or is not provided', async () => {
            const changeFn = jest.spyOn(store, 'onChange');
            await store.put('foo', { foo: 'foo' }, 600);
            expect(await store.get('foo')).toEqual({
                cas: 2,
                ttl: 600,
                value: {
                    foo: 'foo'
                }
            });
            await store.put('foo', { foo: 'bar' }, undefined, 2);
            expect(await store.get('foo')).toEqual({
                cas: 3,
                ttl: 600,
                value: {
                    foo: 'bar'
                }
            });
            expect(changeFn).toHaveBeenCalledTimes(2);
        });
        it('does not overwrite values if the cas does not match', async () => {
            const changeFn = jest.spyOn(store, 'onChange');
            await expect(store.put('foo', { foo: 'bar' }, undefined, 2)).rejects.toThrow(CasError_1.CasError);
            expect(await store.get('foo')).toEqual({
                cas: 1,
                ttl: 500,
                value: {
                    bar: 'bar'
                }
            });
            expect(changeFn).not.toHaveBeenCalled();
        });
    });
    describe('atomicPatch', () => {
        it('updates a value in place', async () => {
            const changeFn = jest.spyOn(store, 'onChange');
            expect(await store.atomicPatch('foo', (prev, options) => {
                options.ttl = 1000;
                return {
                    ...prev,
                    foo: 'foo'
                };
            })).toEqual({
                cas: 2,
                ttl: 1000,
                value: {
                    foo: 'foo',
                    bar: 'bar'
                }
            });
            expect(changeFn).toHaveBeenCalledTimes(1);
        });
        it('overwrites an expired value', async () => {
            const changeFn = jest.spyOn(store, 'onChange');
            jest.spyOn(LocalAsyncStoreBackend_1.LocalAsyncStoreBackend.prototype, 'epoch').mockReturnValue(1585273501);
            expect(await store.atomicPatch('foo', (prev, options) => {
                expect(options).toEqual({});
                expect(prev).toEqual({});
                return {
                    ...prev,
                    foo: 'foo'
                };
            })).toEqual({
                cas: 0,
                value: {
                    foo: 'foo'
                }
            });
            expect(changeFn).toHaveBeenCalledTimes(1);
        });
    });
    describe('delete', () => {
        it('deletes a value', async () => {
            const changeFn = jest.spyOn(store, 'onChange');
            expect(await store.delete('foo')).toEqual({ bar: 'bar' });
            expect(await store.get('foo')).toEqual({
                cas: 0,
                value: {}
            });
            expect(changeFn).toHaveBeenCalledTimes(1);
        });
    });
    describe('exists', () => {
        it('checks if a value exists', async () => {
            expect(await store.exists('foo')).toBeTruthy();
            expect(await store.exists('bar')).toBeFalsy();
            jest.spyOn(LocalAsyncStoreBackend_1.LocalAsyncStoreBackend.prototype, 'epoch').mockReturnValue(1585273501);
            expect(await store.exists('foo')).toBeFalsy();
        });
    });
    describe('onChange', () => {
        it('sends updated data on a change', async () => {
            const changeHandler = jest.fn().mockReturnValue(Promise.resolve());
            store = new LocalAsyncStoreBackend_1.LocalAsyncStoreBackend(0, {}, changeHandler);
            expect(store['hasChanges']).toBeFalsy();
            await store.put('foo', { bar: 'bar' });
            expect(store['changeTimer']).not.toBeUndefined();
            expect(store['hasChanges']).toBeTruthy();
            // ensure we wait for our onChange timer to complete, by scheduling a timer after to complete the test
            return new Promise((resolve) => {
                setTimeout(() => {
                    expect(changeHandler).toHaveBeenCalledWith({ foo: { cas: 0, expires: undefined, value: { bar: 'bar' } } });
                    expect(store['hasChanges']).toBeFalsy();
                    expect(store['changeTimer']).toBeUndefined();
                    resolve();
                }, 0);
            });
        });
    });
});
//# sourceMappingURL=LocalAsyncStoreBackend.test.js.map