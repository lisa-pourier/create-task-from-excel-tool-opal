type PatchUpdater<T> = (previous: T, options: {
    ttl?: number;
}) => T;
interface CasEntry<T> {
    cas: number;
    expires?: number;
    value: T;
}
interface StoreEntry<T> {
    cas: number;
    ttl?: number;
    value: T;
}
/**
 * Simulates access to a remote data store by performing operations asynchronously.
 * Used as a backend for local dev and testing to the local stores
 */
export declare class LocalAsyncStoreBackend<T> {
    private avgDelay;
    private changeHandler?;
    private data;
    private hasChanges;
    private changeTimer?;
    /**
     * @param avgDelay Average delay per request in miliseconds
     */
    constructor(avgDelay?: number, sourceData?: {
        [key: string]: CasEntry<T>;
    }, changeHandler?: ((data: {
        [key: string]: CasEntry<T>;
    }) => Promise<void>) | undefined);
    get<O extends T>(key: string): Promise<StoreEntry<O>>;
    put<O extends T>(key: string, value: O, ttl?: number, cas?: number): Promise<O>;
    /**
     * Normal KV patch is not atomic without CAS and potentially retries. This implementation
     * is specifically for operations that are atomic on the data store side, such as mutating a list.
     * @param key to update
     * @param updater callback to perform atomic update
     */
    atomicPatch<O extends T>(key: string, updater: PatchUpdater<O>): Promise<O>;
    delete<O extends T>(key: string): Promise<O>;
    exists(key: string): Promise<boolean>;
    reset(): void;
    private expired;
    private check;
    private async;
    private copy;
    private translateExpiresToTTL;
    private epoch;
    private onChange;
}
export {};
//# sourceMappingURL=LocalAsyncStoreBackend.d.ts.map