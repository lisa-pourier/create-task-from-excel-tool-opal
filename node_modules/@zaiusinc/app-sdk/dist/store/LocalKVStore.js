"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalKVStore = void 0;
const logging_1 = require("../logging");
const CasError_1 = require("./CasError");
const NumberSet_1 = require("./NumberSet");
const StringSet_1 = require("./StringSet");
function filterFields(result, fields) {
    if (fields && fields.length > 0) {
        const filtered = {};
        fields.forEach((f) => (filtered[f] = result[f]));
        return filtered;
    }
    return result;
}
/**
 * @hidden
 * A stub of the key value store
 *
 * @TODO implement the stub for local development purposes
 */
class LocalKVStore {
    store;
    constructor(store) {
        this.store = store;
    }
    reset() {
        this.store.reset();
    }
    async get(key, fields) {
        return filterFields((await this.store.get(key)).value, fields);
    }
    async put(key, value, options) {
        return (await this.store.put(key, value, options?.ttl)) || {};
    }
    async patch(key, value, options) {
        if (typeof value === 'function') {
            return await this.patchWithRetry(key, value);
        }
        else {
            return await this.patchWithRetry(key, (previous, opts) => {
                opts.ttl = options?.ttl;
                return Object.assign(previous, value);
            });
        }
    }
    async delete(key, fields) {
        if (fields) {
            return await this.store.atomicPatch(key, (value) => {
                for (const field of fields) {
                    delete value[field];
                }
                return value;
            });
        }
        else {
            return await this.store.delete(key);
        }
    }
    async exists(key) {
        return await this.store.exists(key);
    }
    async increment(key, field, amount = 1) {
        return (await this.incrementMulti(key, { [field]: amount }))[key];
    }
    async incrementMulti(key, fieldAmounts) {
        return filterFields(await this.store.atomicPatch(key, (previous, _options) => {
            const fields = Object.keys(fieldAmounts);
            for (const field of fields) {
                if (typeof fieldAmounts[field] !== 'number') {
                    throw new Error(`Cannot increment by non-numeric value for field ${key}.${field}`);
                }
                const value = previous[field];
                if (value == null) {
                    previous[field] = fieldAmounts[field];
                }
                else if (typeof value === 'number' || Number(value).toString() === value) {
                    previous[field] = Number(value) + fieldAmounts[field];
                }
                else {
                    throw new Error(`Cannot increment non-numeric value at ${key}.${field}. Value is type ${typeof value}.`);
                }
            }
            return previous;
        }), Object.keys(fieldAmounts));
    }
    async shift(key, field) {
        const result = await this.shiftMulti(key, { [field]: 1 });
        return result[field] ? result[field][0] : undefined;
    }
    async shiftMulti(key, fieldCounts) {
        const results = {};
        await this.performArrayOperation(key, fieldCounts, (current, field) => {
            if (current == null) {
                results[field] = [];
            }
            else if (Array.isArray(current)) {
                results[field] = current.splice(0, fieldCounts[field]);
            }
            else {
                throw new Error(`Cannot shift from non-array value at ${key}.${field}. Value is type ${typeof current}.`);
            }
            return current;
        });
        return results;
    }
    async unshift(key, field, value) {
        return await this.unshiftMulti(key, { [field]: [value] });
    }
    async unshiftMulti(key, fieldValues) {
        await this.performArrayOperation(key, fieldValues, (current, field) => {
            if (current == null) {
                current = fieldValues[field];
            }
            else if (Array.isArray(current)) {
                current.unshift(...fieldValues[field]);
            }
            else {
                throw new Error(`Cannot unshift into non-array value at ${key}.${field}. Value is type ${typeof current}.`);
            }
            return current;
        });
    }
    async peek(key, field) {
        const result = await this.peekMulti(key, { [field]: 1 });
        return result[field] ? result[field][0] : undefined;
    }
    async peekMulti(key, fieldCounts) {
        const results = {};
        await this.performArrayOperation(key, fieldCounts, (current, field) => {
            if (current == null) {
                results[field] = [];
            }
            else if (Array.isArray(current)) {
                results[field] = current.slice(0, fieldCounts[field]);
            }
            else {
                throw new Error(`Cannot peek non-array value at ${key}.${field}. Value is type ${typeof current}.`);
            }
            return current;
        });
        return results;
    }
    async append(key, field, value) {
        await this.appendMulti(key, { [field]: [value] });
    }
    async appendMulti(key, fieldValues) {
        await this.performArrayOperation(key, fieldValues, (current, field) => {
            if (!Array.isArray(fieldValues[field])) {
                throw new Error(`Cannot append non-array value provided for ${key}.${field}`);
            }
            if (!current) {
                current = [];
            }
            current.push(...fieldValues[field]);
            return current;
        });
    }
    async addNumber(key, field, value) {
        return (await this.addNumberMulti(key, { [field]: [value] }))[field].has(value);
    }
    async addNumberMulti(key, fieldValues) {
        const results = {};
        await this.performSetOperation(key, fieldValues, (current, field) => {
            if (!current) {
                current = new Set();
            }
            results[field] = new NumberSet_1.NumberSet();
            for (const val of fieldValues[field]) {
                if (!current.has(val)) {
                    current.add(val);
                    results[field].add(val);
                }
            }
            return current;
        });
        return results;
    }
    async removeNumber(key, field, value) {
        return (await this.removeNumberMulti(key, { [field]: [value] }))[field].has(value);
    }
    async removeNumberMulti(key, fieldValues) {
        const results = {};
        await this.performSetOperation(key, fieldValues, (current, field) => {
            results[field] = new NumberSet_1.NumberSet();
            for (const val of fieldValues[field]) {
                if (current?.delete(val)) {
                    results[field].add(val);
                }
            }
            return current;
        });
        return results;
    }
    async hasNumber(key, field, value) {
        return (await this.hasNumberMulti(key, { [field]: [value] }))[field].has(value);
    }
    async hasNumberMulti(key, fieldValues) {
        const results = {};
        await this.performSetOperation(key, fieldValues, (current, field) => {
            results[field] = new NumberSet_1.NumberSet();
            for (const val of fieldValues[field]) {
                if (current?.has(val)) {
                    results[field].add(val);
                }
            }
            return current;
        });
        return results;
    }
    async addString(key, field, value) {
        return (await this.addStringMulti(key, { [field]: [value] }))[field].has(value);
    }
    async addStringMulti(key, fieldValues) {
        const results = {};
        await this.performSetOperation(key, fieldValues, (current, field) => {
            if (!current) {
                current = new Set();
            }
            results[field] = new StringSet_1.StringSet();
            for (const val of fieldValues[field]) {
                if (!current.has(val)) {
                    current.add(val);
                    results[field].add(val);
                }
            }
            return current;
        });
        return results;
    }
    async removeString(key, field, value) {
        return (await this.removeStringMulti(key, { [field]: [value] }))[field].has(value);
    }
    async removeStringMulti(key, fieldValues) {
        const results = {};
        await this.performSetOperation(key, fieldValues, (current, field) => {
            results[field] = new StringSet_1.StringSet();
            for (const val of fieldValues[field]) {
                if (current?.delete(val)) {
                    results[field].add(val);
                }
            }
            return current;
        });
        return results;
    }
    async hasString(key, field, value) {
        return (await this.hasStringMulti(key, { [field]: [value] }))[field].has(value);
    }
    async hasStringMulti(key, fieldValues) {
        const results = {};
        await this.performSetOperation(key, fieldValues, (current, field) => {
            results[field] = new StringSet_1.StringSet();
            for (const val of fieldValues[field]) {
                if (current?.has(val)) {
                    results[field].add(val);
                }
            }
            return current;
        });
        return results;
    }
    async performArrayOperation(key, fieldValues, operation) {
        await this.store.atomicPatch(key, (current, _options) => {
            const fields = Object.keys(fieldValues);
            for (const field of fields) {
                const value = current[field];
                if (value == null || Array.isArray(value)) {
                    const update = operation(value == null ? undefined : value, field);
                    current[field] = update ? Array.from(update) : undefined;
                }
                else {
                    throw new Error(`Cannot operate on non-array value at ${key}.${field}. Value is type ${typeof value}.`);
                }
            }
            return current;
        });
    }
    async performSetOperation(key, fieldValues, operation) {
        await this.store.atomicPatch(key, (current, _options) => {
            const fields = Object.keys(fieldValues);
            for (const field of fields) {
                if (!Array.isArray(fieldValues[field])) {
                    throw new Error(`Cannot operate with non-array value provided for ${key}.${field}`);
                }
                const value = current[field];
                if (value == null || Array.isArray(value)) {
                    const update = operation(value == null ? undefined : new Set(value), field);
                    current[field] = update ? Array.from(update) : undefined;
                }
                else {
                    throw new Error(`Cannot operate on non-array value at ${key}.${field}. Value is type ${typeof value}.`);
                }
            }
            return current;
        });
    }
    async patchWithRetry(key, updater, retries = 5) {
        const stored = await this.store.get(key);
        const previous = JSON.stringify(stored.value);
        const options = { ttl: stored.ttl };
        const update = updater(stored.value, options);
        try {
            await this.store.put(key, update, options.ttl, stored.cas);
            return JSON.parse(previous);
        }
        catch (e) {
            if (e instanceof CasError_1.CasError) {
                if (retries > 0) {
                    return this.patchWithRetry(key, updater, retries - 1);
                }
                throw new Error(`Failed to update key ${key}. CAS retries exhausted.`);
            }
            else {
                logging_1.logger.error(e);
            }
            throw new Error(`Failed to update key ${key}`);
        }
    }
}
exports.LocalKVStore = LocalKVStore;
//# sourceMappingURL=LocalKVStore.js.map