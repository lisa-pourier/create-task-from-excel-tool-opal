"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalAsyncStoreBackend = void 0;
const CasError_1 = require("./CasError");
/**
 * Simulates access to a remote data store by performing operations asynchronously.
 * Used as a backend for local dev and testing to the local stores
 */
class LocalAsyncStoreBackend {
    avgDelay;
    changeHandler;
    data;
    hasChanges = false;
    changeTimer;
    /**
     * @param avgDelay Average delay per request in miliseconds
     */
    constructor(avgDelay = 0, sourceData, changeHandler) {
        this.avgDelay = avgDelay;
        this.changeHandler = changeHandler;
        this.data = sourceData || {};
    }
    async get(key) {
        return this.async(() => {
            const entry = this.data[key];
            const epoch = this.epoch();
            if (entry && !this.expired(entry.expires)) {
                return this.translateExpiresToTTL(entry, epoch);
            }
            return { cas: 0, value: {} };
        });
    }
    async put(key, value, ttl, cas) {
        return this.async(() => {
            const entry = this.data[key];
            if (entry && !this.expired(entry.expires)) {
                if (this.check(entry.cas, cas)) {
                    entry.cas++;
                    const previous = entry.value;
                    entry.value = this.copy(value);
                    if (ttl != null) {
                        entry.expires = this.epoch() + ttl;
                    }
                    this.onChange();
                    return previous;
                }
                else {
                    throw new CasError_1.CasError();
                }
            }
            else {
                this.data[key] = {
                    cas: cas ?? 0,
                    expires: ttl && this.epoch() + ttl,
                    value: this.copy(value)
                };
                this.onChange();
                return {};
            }
        });
    }
    /**
     * Normal KV patch is not atomic without CAS and potentially retries. This implementation
     * is specifically for operations that are atomic on the data store side, such as mutating a list.
     * @param key to update
     * @param updater callback to perform atomic update
     */
    async atomicPatch(key, updater) {
        return this.async(() => {
            const entry = this.data[key];
            const epoch = this.epoch();
            if (entry && !this.expired(entry.expires)) {
                // Note: checking the CAS value is not required here because node is single threaded.
                // We can guarantee nothing has changed between now and when we set the value after calling the updater
                const options = {
                    ttl: entry.expires ? entry.expires - epoch : undefined
                };
                entry.value = this.copy(updater(entry.value, options));
                entry.cas++;
                entry.expires = options.ttl == null ? undefined : epoch + options.ttl;
                this.onChange();
            }
            else {
                const options = { ttl: undefined };
                let value = {};
                value = this.copy(updater(value, options));
                this.data[key] = {
                    cas: 0,
                    expires: options.ttl == null ? undefined : epoch + Number(options.ttl),
                    value: this.copy(value)
                };
                this.onChange();
            }
            return this.translateExpiresToTTL(this.data[key], epoch);
        });
    }
    async delete(key) {
        return this.async(() => {
            let value = {};
            if (this.data[key] && !this.expired(this.data[key].expires)) {
                value = this.data[key].value;
            }
            delete this.data[key];
            this.onChange();
            return value;
        });
    }
    async exists(key) {
        return this.async(() => {
            const entry = this.data[key];
            return !!(entry && !this.expired(entry.expires));
        });
    }
    reset() {
        this.data = {};
        this.onChange();
    }
    expired(time) {
        return time && time < this.epoch();
    }
    check(cas, expected) {
        return expected === undefined || cas === expected;
    }
    async async(operation) {
        return new Promise((resolve, reject) => setTimeout(() => {
            try {
                resolve(operation());
            }
            catch (e) {
                reject(e instanceof Error ? e : new Error(String(e)));
            }
        }, this.avgDelay * (0.5 + Math.random())));
    }
    copy(value) {
        return JSON.parse(JSON.stringify(value));
    }
    translateExpiresToTTL(entry, epoch) {
        return {
            cas: entry.cas,
            value: this.copy(entry.value),
            ttl: entry.expires ? entry.expires - epoch : undefined
        };
    }
    epoch() {
        return Math.floor(new Date().getTime() / 1000);
    }
    onChange() {
        this.hasChanges = true;
        if (!this.changeTimer && this.changeHandler) {
            this.changeTimer = setTimeout(async () => {
                if (this.hasChanges && this.changeHandler) {
                    this.hasChanges = false;
                    await this.changeHandler(this.data);
                }
                this.changeTimer = undefined;
                if (this.hasChanges) {
                    this.onChange();
                }
            }, process.env.ZAIUS_ENV === 'test' ? 0 : 10);
        }
    }
}
exports.LocalAsyncStoreBackend = LocalAsyncStoreBackend;
//# sourceMappingURL=LocalAsyncStoreBackend.js.map