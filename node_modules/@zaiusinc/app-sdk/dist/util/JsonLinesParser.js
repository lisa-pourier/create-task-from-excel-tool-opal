"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nullValue = void 0;
exports.parse = parse;
const stream_1 = require("stream");
exports.nullValue = Object.create(null);
const [cr] = Buffer.from('\r');
const [nl] = Buffer.from('\n');
/**
 * @hidden
 * This parser is based on the syntax showed on https://jsonlines.org/
 */
class JsonLinesParser extends stream_1.Transform {
    state = {
        first: false,
        lineNumber: 0,
        previousEnd: 0,
        rowLength: 0
    };
    prev;
    skipComments;
    skipLines = 0;
    maxRowBytes = Number.MAX_SAFE_INTEGER;
    tabularFormat = false;
    headers;
    strict = false;
    constructor(opts = {}) {
        super({ objectMode: true, highWaterMark: 16 });
        if (opts.tabularFormat) {
            this.tabularFormat = true;
            if (opts.headers || opts.headers === false) {
                if (opts.headers === false) {
                    // enforce, as the column length check will fail if headers:false
                    this.strict = false;
                }
                else if (opts.strict) {
                    this.strict = true;
                }
                if (Array.isArray(opts.headers)) {
                    this.headers = opts.headers;
                }
            }
            else {
                this.state.first = true;
                if (opts.strict) {
                    this.strict = true;
                }
            }
        }
    }
    _flush(cb) {
        if (!this.prev)
            return cb();
        this.parseLine(this.prev, this.state.previousEnd, this.prev.length + 1); // plus since online -1s
        cb();
    }
    _transform(data, _enc, cb) {
        if (typeof data === 'string') {
            data = Buffer.from(data);
        }
        let start = 0;
        let buffer = data;
        if (this.prev) {
            start = this.prev.length;
            buffer = Buffer.concat([this.prev, data]);
            this.prev = undefined;
        }
        const bufferLength = buffer.length;
        for (let i = start; i < bufferLength; i++) {
            const chr = buffer[i];
            this.state.rowLength++;
            if (this.state.rowLength > this.maxRowBytes) {
                return cb(new Error('Row exceeds the maximum size'));
            }
            if (chr === nl) {
                this.parseLine(buffer, this.state.previousEnd, i + 1);
                this.state.previousEnd = i + 1;
                this.state.rowLength = 0;
            }
        }
        if (this.state.previousEnd === bufferLength) {
            this.state.previousEnd = 0;
            return cb();
        }
        if (bufferLength - this.state.previousEnd < data.length) {
            this.prev = data;
            this.state.previousEnd -= bufferLength - data.length;
            return cb();
        }
        this.prev = buffer;
        cb();
    }
    parseLine(buffer, start, end) {
        end--; // trim newline
        if (buffer.length && buffer[end - 1] === cr) {
            end--;
        }
        if (this.skipComments) {
            if (buffer[start] === this.skipComments) {
                return;
            }
        }
        try {
            const row = JSON.parse(buffer.subarray(start, end).toString());
            const skip = this.skipLines > this.state.lineNumber;
            this.state.lineNumber++;
            if (!skip) {
                if (this.tabularFormat) {
                    if (Array.isArray(row)) {
                        if (this.state.first) {
                            if (row.every((it) => typeof it === 'string')) {
                                this.state.first = false;
                                this.headers = row;
                                this.emit('headers', this.headers);
                                return;
                            }
                            else {
                                const e = new TypeError('The first line must be an array of strings (headers)');
                                this.emit('error', e);
                            }
                        }
                        if (this.strict && row.length !== this.headers?.length) {
                            const e = new RangeError('Row length does not match headers');
                            this.emit('error', e);
                        }
                        else {
                            this.writeRow(row);
                        }
                    }
                    else {
                        const e = new TypeError('Each line must be an array of objects');
                        this.emit('error', e);
                    }
                }
                else {
                    // Push directly the row as object
                    if (row === null) {
                        this.push(exports.nullValue);
                    }
                    else {
                        this.push(row);
                    }
                }
            }
        }
        catch (e) {
            this.emit('error', e);
        }
    }
    writeRow(cells) {
        const headers = this.headers ? this.headers : cells.map((_value, index) => index);
        const row = cells.reduce((o, cell, index) => {
            const header = headers[index];
            if (header === null)
                return o; // skip columns
            if (header !== undefined) {
                o[header] = cell;
            }
            else {
                o[`_${index}`] = cell;
            }
            return o;
        }, {});
        this.push(row);
    }
}
function parse(opts) {
    return new JsonLinesParser(opts);
}
//# sourceMappingURL=JsonLinesParser.js.map