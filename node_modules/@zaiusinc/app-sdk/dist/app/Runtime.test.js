"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ajv_1 = __importDefault(require("ajv"));
const deep_freeze_1 = __importDefault(require("deep-freeze"));
const fs_1 = __importDefault(require("fs"));
require("jest");
const jsYaml = __importStar(require("js-yaml"));
const mock_fs_1 = __importDefault(require("mock-fs"));
const Runtime_1 = require("./Runtime");
jest.mock('js-yaml');
const appManifest = (0, deep_freeze_1.default)({
    meta: {
        app_id: 'my_app',
        display_name: 'My App',
        version: '1.0.0',
        vendor: 'zaius',
        support_url: 'https://zaius.com',
        summary: 'This is an interesting app',
        contact_email: 'support@zaius.com',
        categories: ['Commerce Platform'],
        availability: ['all']
    },
    runtime: 'node12',
    functions: {
        foo: {
            entry_point: 'Foo',
            description: 'gets foo'
        }
    },
    consumers: {
        loo: {
            entry_point: 'Loo',
            description: 'gets loo'
        }
    },
    jobs: {
        bar: {
            entry_point: 'Bar',
            description: 'Does a thing'
        }
    },
    sources: {
        bar: {
            description: 'the bar source',
            schema: 'barSchema',
            jobs: {
                bar: {
                    entry_point: 'Bar',
                    description: 'Bar'
                }
            }
        }
    },
    liquid_extensions: {
        buzz: {
            entry_point: 'Buzz',
            description: 'Buzzes'
        }
    }
});
const schemaObjects = (0, deep_freeze_1.default)({
    'schema/events.yml': {
        name: 'events',
        fields: [
            {
                name: 'my_app_coupon_id',
                type: 'string',
                display_name: 'My App Coupon ID',
                description: 'The coupon associated with this event'
            }
        ],
        relations: [
            {
                name: 'my_app_coupon',
                display_name: 'My App Coupon',
                child_object: 'my_app_coupons',
                join_fields: [
                    {
                        parent: 'my_app_coupon_id',
                        child: 'coupon_id'
                    }
                ]
            }
        ]
    },
    'schema/my_app_coupons.yaml': {
        name: 'my_app_coupons',
        display_name: 'My App Coupons',
        fields: [
            {
                name: 'coupon_id',
                type: 'string',
                display_name: 'Coupon ID',
                description: 'The Coupon ID',
                primary: true
            },
            {
                name: 'percent_off',
                type: 'number',
                display_name: 'Percent Off',
                description: 'Percentage discount'
            }
        ]
    }
});
describe('Runtime', () => {
    beforeAll(() => {
        (0, mock_fs_1.default)({
            '/tmp/foo': {
                'app.yml': JSON.stringify(appManifest),
                schema: {
                    'events.yml': JSON.stringify(schemaObjects['schema/events.yml']),
                    'my_app_coupons.yaml': JSON.stringify(schemaObjects['schema/my_app_coupons.yaml']),
                    'something_else.yml.txt': 'something else'
                }
            }
        });
    });
    afterAll(() => {
        mock_fs_1.default.restore();
    });
    describe('initialize', () => {
        it('loads and validates the manifest', async () => {
            const yamlLoadFn = jest.spyOn(jsYaml, 'load').mockImplementation((data) => JSON.parse(data));
            const validateFn = jest.spyOn(ajv_1.default.prototype, 'validate').mockReturnValue(true);
            const runtime = await Runtime_1.Runtime.initialize('/tmp/foo');
            expect(yamlLoadFn).toHaveBeenCalled();
            expect(validateFn).toHaveBeenCalled();
            expect(JSON.parse(runtime.toJson())).toEqual({
                appManifest,
                dirName: '/tmp/foo'
            });
            yamlLoadFn.mockRestore();
            validateFn.mockRestore();
        });
        it('throws an error when the manifest is invalid', async () => {
            const yamlLoadFn = jest.spyOn(jsYaml, 'load').mockImplementation((data) => JSON.parse(data));
            const validateFn = jest.spyOn(ajv_1.default.prototype, 'validate').mockReturnValue(false);
            try {
                await Runtime_1.Runtime.initialize('/tmp/foo');
            }
            catch (e) {
                expect(e.message).toMatch(/Invalid app.yml manifest/);
            }
            yamlLoadFn.mockRestore();
            validateFn.mockRestore();
        });
    });
    describe('fromJson', () => {
        it('restores from serialized json', () => {
            const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
            expect(runtime.manifest).toEqual(appManifest);
            expect(runtime['dirName']).toEqual('/tmp/foo');
        });
    });
    describe('toJson', () => {
        it('serializes to json', () => {
            const json = JSON.stringify({ appManifest, dirName: '/tmp/foo' });
            const runtime = Runtime_1.Runtime.fromJson(json);
            expect(runtime.toJson()).toEqual(json);
        });
    });
    describe('getFunctionClass', () => {
        it('loads the specified module', async () => {
            const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
            const importFn = jest.spyOn(runtime, 'import').mockResolvedValue({ Foo: 'Foo' });
            const foo = await runtime.getFunctionClass('foo');
            expect(importFn).toHaveBeenCalledWith('/tmp/foo/functions/Foo');
            expect(foo).toEqual('Foo');
            importFn.mockRestore();
        });
        it("throws an error the function isn't in the manifest", async () => {
            const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
            try {
                await runtime.getFunctionClass('bar');
            }
            catch (e) {
                expect(e.message).toMatch(/^No function named bar/);
            }
        });
    });
    describe('getJobClass', () => {
        it('loads the specified module', async () => {
            const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
            const importFn = jest.spyOn(runtime, 'import').mockResolvedValue({ Bar: 'Bar' });
            const bar = await runtime.getJobClass('bar');
            expect(importFn).toHaveBeenCalledWith('/tmp/foo/jobs/Bar');
            expect(bar).toEqual('Bar');
            importFn.mockRestore();
        });
        it("throws an error the job isn't in the manifest", async () => {
            const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
            try {
                await runtime.getJobClass('foo');
            }
            catch (e) {
                expect(e.message).toMatch(/^No job named foo/);
            }
        });
    });
    describe('getSourceJobClass', () => {
        it('loads the specified module', async () => {
            const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
            const importFn = jest.spyOn(runtime, 'import').mockResolvedValue({ Bar: 'Bar' });
            const bar = await runtime.getSourceJobClass('bar', 'bar');
            expect(importFn).toHaveBeenCalledWith('/tmp/foo/sources/jobs/Bar');
            expect(bar).toEqual('Bar');
            importFn.mockRestore();
        });
        it("throws an error the job isn't in the manifest", async () => {
            const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
            try {
                await runtime.getSourceJobClass('bar', 'foo');
            }
            catch (e) {
                expect(e.message).toMatch(/^No source job named foo defined/);
            }
        });
    });
    describe('getLiquidExtensionClass', () => {
        it('loads the specified module', async () => {
            const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
            const importFn = jest.spyOn(runtime, 'import').mockResolvedValue({ Buzz: 'Buzz' });
            const buzz = await runtime.getLiquidExtensionClass('buzz');
            expect(importFn).toHaveBeenCalledWith('/tmp/foo/liquid-extensions/Buzz');
            expect(buzz).toEqual('Buzz');
            importFn.mockRestore();
        });
        it("throws an error if the liquid extension isn't in the manifest", async () => {
            const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
            try {
                await runtime.getLiquidExtensionClass('bar');
            }
            catch (e) {
                expect(e.message).toMatch(/^No liquid extension named bar/);
            }
        });
    });
    describe('getLifecycleClass', () => {
        it('loads the lifecycle module', async () => {
            const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
            const importFn = jest.spyOn(runtime, 'import').mockResolvedValue({ Lifecycle: 'Lifecycle' });
            const lifecycle = await runtime.getLifecycleClass();
            expect(importFn).toHaveBeenCalledWith('/tmp/foo/lifecycle/Lifecycle');
            expect(lifecycle).toEqual('Lifecycle');
            importFn.mockRestore();
        });
    });
    describe('getChannelClass', () => {
        it('loads the channel module', async () => {
            const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
            const importFn = jest.spyOn(runtime, 'import').mockResolvedValue({ Channel: 'Channel' });
            const channel = await runtime.getChannelClass();
            expect(importFn).toHaveBeenCalledWith('/tmp/foo/channel/Channel');
            expect(channel).toEqual('Channel');
            importFn.mockRestore();
        });
    });
    describe('getSchemaObjects', () => {
        it('loads all .yml and .yaml files in the schema directory', () => {
            const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
            const origReadFileSync = fs_1.default.readFileSync;
            const readFileSyncFn = jest.spyOn(fs_1.default, 'readFileSync').mockImplementation(origReadFileSync);
            const yamlLoadFn = jest.spyOn(jsYaml, 'load').mockImplementation((data) => JSON.parse(data));
            const result = runtime.getSchemaObjects();
            expect(readFileSyncFn.mock.calls).toEqual([
                ['/tmp/foo/schema/my_app_coupons.yaml', 'utf8'],
                ['/tmp/foo/schema/events.yml', 'utf8']
            ]);
            expect(result).toEqual(schemaObjects);
            readFileSyncFn.mockRestore();
            yamlLoadFn.mockRestore();
        });
    });
});
//# sourceMappingURL=Runtime.test.js.map