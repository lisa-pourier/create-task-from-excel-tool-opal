"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CampaignEvents = void 0;
const node_sdk_1 = require("@zaiusinc/node-sdk");
const AppContext_1 = require("../AppContext");
const Batcher_1 = require("./Batcher");
/**
 * A class to help batch and send campaign related events
 */
class CampaignEvents {
    identifierField;
    tracking;
    /**
     * The campaign event type
     */
    type;
    reachabilityBatcher = new Batcher_1.Batcher(node_sdk_1.z.identifier.updateReachability);
    consentBatcher = new Batcher_1.Batcher(node_sdk_1.z.identifier.updateConsent);
    eventBatcher = new Batcher_1.Batcher(node_sdk_1.z.event);
    /**
     * @param tracking Campaign tracking information to be included on every event.
     * Use an empty {} if you plan to provide different tracking info for each event,
     * otherwise a complete CampaignTracking object.
     * @param identifierField the name of the identifier field used to target the user.
     * The identifier value provided to a campaign event must be for this identifier field name.
     */
    constructor(identifierField, tracking, type) {
        this.identifierField = identifierField;
        this.tracking = tracking;
        if (!type) {
            type = (0, AppContext_1.getAppContext)()?.manifest.channel?.type;
            if (!type) {
                throw new Error('Type is required for generating a campaign event');
            }
        }
        this.type = type;
    }
    /**
     * Flush all API batches. You MUST flush before your task exists if you generated any events.
     */
    async flush() {
        await this.reachabilityBatcher.flush();
        await this.consentBatcher.flush();
        await this.eventBatcher.flush();
    }
    /**
     * Send a campaign related event
     * @param identifier the identifier value / target identifier value related to this event
     * @param action the campaign action
     * @param ts the time of the event. If left blank, the recevied time will be used.
     * @param data additional event data to add to the event
     */
    async event(identifier, action, ts, data) {
        await this.eventBatcher.append({
            identifiers: {
                [this.identifierField]: identifier
            },
            type: this.type,
            action,
            data: {
                ts: ts instanceof Date ? ts.toISOString() : ts,
                target_address: identifier,
                ...this.tracking,
                ...data
            }
        });
    }
    /**
     * Send a campaign delivery event
     * @param identifier the identifier value / target identifier value related to this event
     * @param ts the time of the event. If left blank, the recevied time will be used.
     * @param data additional event data to add to the event
     */
    async delivery(identifier, ts, data) {
        await this.event(identifier, 'delivery', ts, data);
    }
    /**
     * Send a campaign open event
     * @param identifier the identifier value / target identifier value related to this event
     * @param ts the time of the event. If left blank, the recevied time will be used.
     * @param data additional event data to add to the event
     */
    async open(identifier, ts, data) {
        await this.event(identifier, 'open', ts, data);
    }
    /**
     * Send a campaign click event
     * @param identifier the identifier value / target identifier value related to this event
     * @param ts the time of the event. If left blank, the recevied time will be used.
     * @param data additional event data to add to the event
     */
    async click(identifier, ts, data) {
        await this.event(identifier, 'click', ts, data);
    }
    /**
     * Send a campaign engage event
     * @param identifier the identifier value / target identifier value related to this event
     * @param ts the time of the event. If left blank, the recevied time will be used.
     * @param data additional event data to add to the event
     */
    async engage(identifier, ts, data) {
        await this.event(identifier, 'engage', ts, data);
    }
    /**
     * Send a campaign disengage event
     * @param identifier the identifier value / target identifier value related to this event
     * @param ts the time of the event. If left blank, the recevied time will be used.
     * @param data additional event data to add to the event
     */
    async disengage(identifier, ts, data) {
        await this.event(identifier, 'disengage', ts, data);
    }
    /**
     * Send a campaign hard bounce event, which means you were unable to deliver AND
     * the identifier is definitely no longer reachable. E.g., an invalid address.
     * @param identifier the identifier value / target identifier value related to this event
     * @param reason a human readable reason for the hard bounce
     * @param ts the time of the event. If left blank, the recevied time will be used.
     * @param data additional event data to add to the event
     */
    async hardBounce(identifier, reason, ts, data) {
        await this.reachabilityBatcher.append({
            identifier_field_name: this.identifierField,
            identifier_value: identifier,
            reachable: false,
            reachable_update_type: 'hard_bounce',
            reachable_update_reason: reason,
            reachable_update_ts: ts,
            event_data: {
                ...this.tracking,
                ...data
            }
        });
    }
    /**
     * Send a campaign soft bounce event, which means you were unable to deliver,
     * but the identifier may still be reachable. E.g., the provider is temporarily unavailable.
     * @param identifier the identifier value / target identifier value related to this event
     * @param reason a human readable reason for the soft bounce
     * @param ts the time of the event. If left blank, the recevied time will be used.
     * @param data additional event data to add to the event
     */
    async softBounce(identifier, reason, ts, data) {
        await this.event(identifier, 'soft_bounce', ts, { value: `Reason: ${reason}`, ...data });
    }
    // TODO: Awaiting confirmation of behavior of spam report before adding
    // /**
    //  * Send a campaign related spam report event, which means the customer reported this message as spam and
    //  * will be automatically opted out of future communications at this identifier (e.g., revokes consent).
    //  * @param identifier the identifier value / target identifier value related to this event
    //  * @param ts the time of the event. If left blank, the recevied time will be used.
    //  * @param data additional event data to add to the event
    //  */
    // public async spamReport(identifier: string, ts?: Date | string | number, data?: EventData) {
    //   await this.optOut(identifier, 'spam_report', ts, data);
    // }
    /**
     * Send a campaign related opt-out event, such as, when a customer unsubscribes or replies STOP to an SMS.
     * Consent will be revoked on the identifier.
     * @param identifier the identifier value / target identifier value related to this event
     * @param reason a human readable reason for the opt-out
     * @param ts the time of the event. If left blank, the recevied time will be used.
     * @param data additional event data to add to the event
     */
    async optOut(identifier, reason, ts, data) {
        await this.consentBatcher.append({
            identifier_field_name: this.identifierField,
            identifier_value: identifier,
            consent: false,
            consent_update_reason: reason,
            consent_update_ts: ts,
            event_data: {
                ...this.tracking,
                ...data
            }
        });
    }
    /**
     * Send a campaign related opt-in event, such as, when a customer re-subscribes or replies UNSTOP to an SMS.
     * This is considered a consent opt-in for the identifier.
     * @param identifier the identifier value / target identifier value related to this event
     * @param reason a human readable reason for the opt-in
     * @param ts the time of the event. If left blank, the recevied time will be used.
     * @param data additional event data to add to the event
     */
    async optIn(identifier, reason, ts, data) {
        await this.consentBatcher.append({
            identifier_field_name: this.identifierField,
            identifier_value: identifier,
            consent: true,
            consent_update_reason: reason,
            consent_update_ts: ts,
            event_data: {
                ...this.tracking,
                ...data
            }
        });
    }
}
exports.CampaignEvents = CampaignEvents;
//# sourceMappingURL=CampaignEvents.js.map