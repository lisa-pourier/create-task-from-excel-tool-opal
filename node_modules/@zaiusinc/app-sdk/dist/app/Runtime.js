"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Runtime = exports.FunctionClassNotFoundError = void 0;
/* eslint-disable max-classes-per-file */
const ajv_1 = __importDefault(require("ajv"));
const deep_freeze_1 = __importDefault(require("deep-freeze"));
const fs_1 = require("fs");
const glob = __importStar(require("glob"));
const jsYaml = __importStar(require("js-yaml"));
const path_1 = require("path");
const AppManifest_schema_json_1 = __importDefault(require("./types/AppManifest.schema.json"));
class FunctionClassNotFoundError extends Error {
}
exports.FunctionClassNotFoundError = FunctionClassNotFoundError;
class Runtime {
    /**
     * Initializes from a directory. Used during startup.
     * @param dirName the base directory of the app
     * @param skipJsonValidation for internal use, allows json-schema errors to be captured by the validation process
     */
    static async initialize(dirName, skipJsonValidation = false) {
        const runtime = new Runtime();
        await runtime.initialize(dirName, skipJsonValidation);
        return runtime;
    }
    /**
     * Initializes from a pre-validated JSON definition. Used during task execution.
     * @param serializedRuntime JSON-serialized runtime definition
     */
    static fromJson(serializedRuntime) {
        const data = JSON.parse(serializedRuntime);
        const runtime = new Runtime();
        Object.assign(runtime, data);
        return runtime;
    }
    appManifest;
    dirName;
    get manifest() {
        return this.appManifest;
    }
    get baseDir() {
        return this.dirName;
    }
    // eslint-disable-next-line @typescript-eslint/no-restricted-types
    async getFunctionClass(name) {
        const functions = this.manifest.functions;
        if (!functions || !functions[name]) {
            throw new FunctionClassNotFoundError(`No function named ${name} defined in manifest`);
        }
        const fn = functions[name];
        return (await this.import((0, path_1.join)(this.dirName, 'functions', fn.entry_point)))[fn.entry_point];
    }
    async getLifecycleClass() {
        return (await this.import((0, path_1.join)(this.dirName, 'lifecycle', 'Lifecycle')))['Lifecycle'];
    }
    async getChannelClass() {
        return (await this.import((0, path_1.join)(this.dirName, 'channel', 'Channel')))['Channel'];
    }
    async getJobClass(name) {
        const jobs = this.manifest.jobs;
        if (!jobs || !jobs[name]) {
            throw new Error(`No job named ${name} defined in manifest`);
        }
        const job = jobs[name];
        return (await this.import((0, path_1.join)(this.dirName, 'jobs', job.entry_point)))[job.entry_point];
    }
    async getSourceJobClass(sourceName, jobName) {
        const source = this.manifest.sources;
        if (!source || !source[sourceName]) {
            throw new Error(`No source named ${sourceName} defined in manifest`);
        }
        const jobs = source[sourceName].jobs;
        if (!jobs || !jobs[jobName]) {
            throw new Error(`No source job named ${jobName} defined in manifest`);
        }
        const job = jobs[jobName];
        return (await this.import((0, path_1.join)(this.dirName, 'sources/jobs', job.entry_point)))[job.entry_point];
    }
    async getDestinationClass(name) {
        const destinations = this.manifest.destinations;
        if (!destinations || !destinations[name]) {
            throw new Error(`No destination ${name} defined in manifest`);
        }
        const destination = destinations[name];
        return (await this.import((0, path_1.join)(this.dirName, 'destinations', destination.entry_point)))[destination.entry_point];
    }
    async getSourceLifecycleClass(name) {
        const sources = this.manifest.sources;
        if (!sources || !sources[name]) {
            throw new Error(`No source '${name}' defined in manifest`);
        }
        const lifecycleEntryPoint = sources[name].lifecycle?.entry_point;
        if (!lifecycleEntryPoint) {
            return null;
        }
        return (await this.import((0, path_1.join)(this.dirName, 'sources', lifecycleEntryPoint)))[lifecycleEntryPoint];
    }
    async getDestinationSchemaFunctionClass(name) {
        const destinations = this.manifest.destinations;
        if (!destinations || !destinations[name]) {
            throw new Error(`No destination '${name}' defined in manifest`);
        }
        if (typeof destinations[name].schema === 'string') {
            throw new Error(`Schema defined for destination '${name}' is not a function`);
        }
        const providerEntryPoint = destinations[name].schema.entry_point;
        if (!providerEntryPoint) {
            throw new Error(`destination '${name}' doesn't have a schema function`);
        }
        return (await this.import((0, path_1.join)(this.dirName, 'destinations', providerEntryPoint)))[providerEntryPoint];
    }
    async getSourceSchemaFunctionClass(name) {
        const sources = this.manifest.sources;
        if (!sources || !sources[name]) {
            throw new Error(`No source '${name}' defined in manifest`);
        }
        if (typeof sources[name].schema === 'string') {
            throw new Error(`Schema defined for source '${name}' is not a function`);
        }
        const providerEntryPoint = sources[name].schema.entry_point;
        if (!providerEntryPoint) {
            throw new Error(`Source '${name}' doesn't have a schema function`);
        }
        return (await this.import((0, path_1.join)(this.dirName, 'sources', providerEntryPoint)))[providerEntryPoint];
    }
    async getSourceFunctionClass(name) {
        const sources = this.manifest.sources;
        if (!sources || !sources[name]) {
            throw new Error(`No source '${name}' defined in manifest`);
        }
        const functionEntryPoint = sources[name].function?.entry_point;
        if (!functionEntryPoint) {
            throw new Error(`Source '${name}' is not a function source`);
        }
        return (await this.import((0, path_1.join)(this.dirName, 'sources', functionEntryPoint)))[functionEntryPoint];
    }
    async getLiquidExtensionClass(name) {
        const liquidExtensions = this.manifest.liquid_extensions;
        if (!liquidExtensions || !liquidExtensions[name]) {
            throw new Error(`No liquid extension named ${name} defined in manifest`);
        }
        const ext = liquidExtensions[name];
        return (await this.import((0, path_1.join)(this.dirName, 'liquid-extensions', ext.entry_point)))[ext.entry_point];
    }
    getSchemaObjects() {
        return this.getSchema('schema');
    }
    getDestinationSchema() {
        return this.getSchema('destinations/schema');
    }
    getSourceSchema() {
        return this.getSchema('sources/schema');
    }
    getSchema(path) {
        const schemaObjects = {};
        const files = glob.sync(`${path}/*.{yml,yaml}`, { cwd: this.dirName });
        if (files.length > 0) {
            for (const file of files) {
                schemaObjects[file] = jsYaml.load((0, fs_1.readFileSync)((0, path_1.join)(this.dirName, file), 'utf8'));
            }
        }
        return schemaObjects;
    }
    toJson() {
        return JSON.stringify({
            appManifest: this.manifest,
            dirName: this.dirName
        });
    }
    // necessary for test purposes
    async import(path) {
        return await Promise.resolve(`${path}`).then(s => __importStar(require(s)));
    }
    async initialize(dirName, skipJsonValidation) {
        this.dirName = dirName;
        // dynamically import libraries only needed on the main thread so we don't also load them on worker threads
        const manifest = (await Promise.resolve().then(() => __importStar(require('js-yaml')))).load((0, fs_1.readFileSync)((0, path_1.join)(dirName, 'app.yml'), 'utf8'));
        if (!skipJsonValidation) {
            const ajv = new ajv_1.default({ allowUnionTypes: true });
            if (!ajv.validate(AppManifest_schema_json_1.default, manifest)) {
                throw new Error('Invalid app.yml manifest (failed JSON schema validation)');
            }
        }
        this.appManifest = (0, deep_freeze_1.default)(manifest);
    }
}
exports.Runtime = Runtime;
//# sourceMappingURL=Runtime.js.map