"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateFunctions = validateFunctions;
const jsonpath_1 = __importDefault(require("jsonpath"));
const Function_1 = require("../Function");
const GlobalFunction_1 = require("../GlobalFunction");
const Runtime_1 = require("../Runtime");
async function validateFunctions(runtime) {
    const errors = [];
    // Make sure all the functions listed in the manifest actually exist and are implemented
    if (runtime.manifest.functions) {
        for (const name of Object.keys(runtime.manifest.functions)) {
            const fnDefinition = runtime.manifest.functions[name];
            let fnClass = null;
            let errorMessage = null;
            try {
                fnClass = await runtime.getFunctionClass(name);
            }
            catch (e) {
                if (!(e instanceof Runtime_1.FunctionClassNotFoundError)) {
                    const msg = e.message;
                    errors.push(`Failed to load function class ${name}.  Error was: ${msg}`);
                    return errors;
                }
                errorMessage = e instanceof Error ? e.message : String(e);
            }
            if (!fnClass) {
                errors.push(`Error loading function class ${name}. Error: ${errorMessage}`);
            }
            else if (!fnDefinition.global && !(fnClass.prototype instanceof Function_1.Function)) {
                errors.push(`Function entry point does not extend App.Function: ${fnDefinition.entry_point}`);
            }
            else if (fnDefinition.global && !(fnClass.prototype instanceof GlobalFunction_1.GlobalFunction)) {
                errors.push(`Global Function entry point does not extend App.GlobalFunction: ${fnDefinition.entry_point}`);
            }
            else if (typeof fnClass.prototype.perform !== 'function') {
                errors.push(`Function entry point is missing the perform method: ${fnDefinition.entry_point}`);
            }
            const installationResolutionErrors = await validateInstallationResolution(fnDefinition);
            if (installationResolutionErrors.length) {
                errors.push(...installationResolutionErrors);
            }
        }
    }
    return errors;
}
async function validateInstallationResolution(definition) {
    if (definition.global && definition.installation_resolution) {
        return ['Global functions cannot define a installation_resolution'];
    }
    if (definition.installation_resolution) {
        const { type, key } = definition.installation_resolution;
        if (type === 'JSON_BODY_FIELD') {
            try {
                jsonpath_1.default.parse(key);
            }
            catch (e) {
                return [`Invalid JSON path expression: ${e.message}`];
            }
        }
    }
    return [];
}
//# sourceMappingURL=validateFunctions.js.map