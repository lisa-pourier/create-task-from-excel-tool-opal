"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const deep_freeze_1 = __importDefault(require("deep-freeze"));
require("jest");
const Channel_1 = require("../../Channel");
const Runtime_1 = require("../../Runtime");
const lib_1 = require("../../lib");
const validateChannel_1 = require("../validateChannel");
const staticManifest = (0, deep_freeze_1.default)({
    meta: {
        app_id: 'my_app',
        display_name: 'My App',
        version: '1.0.0',
        vendor: 'zaius',
        support_url: 'https://zaius.com',
        summary: 'This is an interesting app',
        contact_email: 'support@zaius.com',
        categories: ['Channel'],
        availability: ['all']
    },
    runtime: 'node12',
    channel: {
        type: 'sms',
        targeting: [{ identifier: 'my_app_identifier' }],
        options: {
            prepare: false
        },
        delivery: {
            batch_size: 10,
            concurrent_batches: 5,
            rate_limits: [
                {
                    count: 20,
                    period: 1,
                    unit: 'minute',
                    grouping: 'install'
                }
            ]
        }
    }
});
const dynamicManifest = (0, deep_freeze_1.default)({
    meta: staticManifest.meta,
    runtime: 'node12',
    channel: {
        type: 'sms',
        targeting: 'dynamic'
    }
});
const badManifest = (0, deep_freeze_1.default)({
    meta: staticManifest.meta,
    runtime: 'node12'
});
const manifestWithoutTargeting = (0, deep_freeze_1.default)({
    meta: staticManifest.meta,
    runtime: 'node12',
    channel: {
        type: 'sms'
    }
});
class NonExtendedChannel {
}
class PartialChannel extends Channel_1.Channel {
    constructor() {
        super();
    }
}
class ProperChannel extends Channel_1.Channel {
    constructor() {
        super();
    }
    async ready() {
        return true;
    }
    async validate(_content, _options) {
        return new lib_1.ChannelContentResult();
    }
    async publish(_contentKey, _content, _options) {
        return new lib_1.ChannelContentResult();
    }
    async deliver(_contentKey, _tracking, _options, _batch, _previousResult) {
        return { success: true };
    }
    async preview(_content, _batch) {
        return new lib_1.ChannelPreviewResult();
    }
}
class MoreProperChannel extends ProperChannel {
    constructor() {
        super();
    }
    async target(_contentSettings) {
        return new lib_1.ChannelTargetResult();
    }
    async prepare(_contentKey, _tracking, _options) {
        return { success: true };
    }
}
describe('validateChannel', () => {
    it('succeeds with a proper static-targeting definition', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest: staticManifest, dirName: '/tmp/foo' }));
        const getChannelClass = jest.spyOn(Runtime_1.Runtime.prototype, 'getChannelClass').mockResolvedValue(ProperChannel);
        const errors = await (0, validateChannel_1.validateChannel)(runtime);
        expect(getChannelClass).toHaveBeenCalled();
        expect(errors).toEqual([]);
        getChannelClass.mockRestore();
    });
    it('succeeds with a proper dynamic-targeting definition', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest: dynamicManifest, dirName: '/tmp/foo' }));
        const getChannelClass = jest.spyOn(Runtime_1.Runtime.prototype, 'getChannelClass').mockResolvedValue(MoreProperChannel);
        const errors = await (0, validateChannel_1.validateChannel)(runtime);
        expect(getChannelClass).toHaveBeenCalled();
        expect(errors).toEqual([]);
        getChannelClass.mockRestore();
    });
    it('detects missing channel configuration', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest: badManifest, dirName: '/tmp/foo' }));
        const getChannelClass = jest.spyOn(Runtime_1.Runtime.prototype, 'getChannelClass').mockResolvedValue(ProperChannel);
        expect(await (0, validateChannel_1.validateChannel)(runtime)).toEqual([
            'Invalid app.yml: channel must exist when meta.categories includes "Channel"',
            expect.stringContaining('Channel implementation is missing the prepare method')
        ]);
        getChannelClass.mockRestore();
    });
    it('detects missing target configuration', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest: manifestWithoutTargeting, dirName: '/tmp/foo' }));
        const getChannelClass = jest.spyOn(Runtime_1.Runtime.prototype, 'getChannelClass').mockResolvedValue(ProperChannel);
        expect(await (0, validateChannel_1.validateChannel)(runtime)).toEqual([
            'Invalid app.yml: channel.targeting cannot be blank for a channel app',
            expect.stringContaining('Channel implementation is missing the prepare method')
        ]);
        getChannelClass.mockRestore();
    });
    it('detects missing channel implementation', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest: staticManifest, dirName: '/tmp/foo' }));
        const getChannelClass = jest.spyOn(Runtime_1.Runtime.prototype, 'getChannelClass').mockRejectedValue(new Error('not found'));
        expect(await (0, validateChannel_1.validateChannel)(runtime)).toEqual(['Error loading Channel implementation. Error: not found']);
        getChannelClass.mockRestore();
    });
    it('detects non-extended channel implementation', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest: staticManifest, dirName: '/tmp/foo' }));
        const getChannelClass = jest
            .spyOn(Runtime_1.Runtime.prototype, 'getChannelClass')
            .mockResolvedValue(NonExtendedChannel);
        expect(await (0, validateChannel_1.validateChannel)(runtime)).toEqual(['Channel implementation does not extend App.Channel']);
        getChannelClass.mockRestore();
    });
    it('detects partial channel implementation', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest: staticManifest, dirName: '/tmp/foo' }));
        const getChannelClass = jest.spyOn(Runtime_1.Runtime.prototype, 'getChannelClass').mockResolvedValue(PartialChannel);
        expect(await (0, validateChannel_1.validateChannel)(runtime)).toEqual([
            'Channel implementation is missing the ready method',
            'Channel implementation is missing the validate method',
            'Channel implementation is missing the publish method',
            'Channel implementation is missing the deliver method',
            'Channel implementation is missing the preview method'
        ]);
        getChannelClass.mockRestore();
    });
    it('detects missing prepare implementation when required', async () => {
        const manifest = {
            ...staticManifest,
            channel: {
                ...staticManifest.channel,
                options: {
                    ...staticManifest.channel?.options,
                    prepare: true
                }
            }
        };
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest: manifest, dirName: '/tmp/foo' }));
        const getChannelClass = jest.spyOn(Runtime_1.Runtime.prototype, 'getChannelClass').mockResolvedValue(ProperChannel);
        expect(await (0, validateChannel_1.validateChannel)(runtime)).toEqual([
            expect.stringMatching('Channel implementation is missing the prepare method')
        ]);
        getChannelClass.mockRestore();
    });
    it('detects unused target implementation when not required', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest: staticManifest, dirName: '/tmp/foo' }));
        const getChannelClass = jest
            .spyOn(Runtime_1.Runtime.prototype, 'getChannelClass')
            .mockResolvedValue(MoreProperChannel);
        expect(await (0, validateChannel_1.validateChannel)(runtime)).toEqual([
            'Channel implementation implements the prepare method, but the channel options specify you do not need prepare',
            'Channel implementation implements the target method, but it will not be used with static targeting'
        ]);
        getChannelClass.mockRestore();
    });
    it('detects missing target implementation when required', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest: dynamicManifest, dirName: '/tmp/foo' }));
        const getChannelClass = jest.spyOn(Runtime_1.Runtime.prototype, 'getChannelClass').mockResolvedValue(ProperChannel);
        expect(await (0, validateChannel_1.validateChannel)(runtime)).toEqual([
            expect.stringContaining('Channel implementation is missing the prepare method'),
            'Channel implementation is missing the target method (required for dynamic targeting)'
        ]);
        getChannelClass.mockRestore();
    });
    it('detects detects invalid delivery options', async () => {
        const manifest = {
            ...staticManifest,
            channel: {
                ...staticManifest.channel,
                delivery: {
                    batch_size: 15.5,
                    concurrent_batches: 13.2
                }
            }
        };
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest: manifest, dirName: '/tmp/foo' }));
        const getChannelClass = jest.spyOn(Runtime_1.Runtime.prototype, 'getChannelClass').mockResolvedValue(ProperChannel);
        expect(await (0, validateChannel_1.validateChannel)(runtime)).toEqual([
            'channel.delivery.batch_size must be an integer',
            'channel.delivery.concurrent_batches must be an integer'
        ]);
        Object.assign(runtime.manifest.channel?.delivery, {
            batch_size: -1,
            concurrent_batches: -1
        });
        expect(await (0, validateChannel_1.validateChannel)(runtime)).toEqual([
            'channel.delivery.batch_size must be between 1 and 1000 (inclusive)',
            'channel.delivery.concurrent_batches must be between 1 and 1000 (inclusive)'
        ]);
        Object.assign(runtime.manifest.channel?.delivery, {
            batch_size: 10000,
            concurrent_batches: 1001
        });
        expect(await (0, validateChannel_1.validateChannel)(runtime)).toEqual([
            'channel.delivery.batch_size must be between 1 and 1000 (inclusive)',
            'channel.delivery.concurrent_batches must be between 1 and 1000 (inclusive)'
        ]);
        getChannelClass.mockRestore();
    });
    it('detects detects invalid rate limit options', async () => {
        const manifest = {
            ...staticManifest,
            channel: {
                ...staticManifest.channel,
                delivery: {
                    batch_size: 100,
                    concurrent_batches: 10,
                    rate_limits: [
                        {
                            count: 0,
                            period: 0,
                            unit: 'second',
                            grouping: 'install'
                        },
                        {
                            count: 1.25,
                            period: 1.99,
                            unit: 'minute',
                            grouping: 'app'
                        }
                    ]
                }
            }
        };
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest: manifest, dirName: '/tmp/foo' }));
        const getChannelClass = jest.spyOn(Runtime_1.Runtime.prototype, 'getChannelClass').mockResolvedValue(ProperChannel);
        expect(await (0, validateChannel_1.validateChannel)(runtime)).toEqual([
            'channel.delivery.rate_limit[0].count must be > 0',
            'channel.delivery.rate_limit[0].period must be > 0 if specifying a number of seconds',
            'channel.delivery.rate_limit[1].count must be an integer',
            'channel.delivery.rate_limit[1].period must be an integer'
        ]);
        getChannelClass.mockRestore();
    });
});
//# sourceMappingURL=validateChannel.test.js.map