"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable max-classes-per-file */
const fs_1 = __importDefault(require("fs"));
const Destination_1 = require("../../Destination");
const DestinationSchemaFunction_1 = require("../../DestinationSchemaFunction");
const validateDestinations_1 = require("../validateDestinations");
class ValidDestination extends Destination_1.Destination {
    getDestinationSchema() {
        throw new Error('Method not implemented.');
    }
    async ready() {
        return { ready: true };
    }
    async deliver(batch) {
        return { success: !batch };
    }
}
class ValidDestinationSchemaFunction extends DestinationSchemaFunction_1.DestinationSchemaFunction {
    async getDestinationsSchema() {
        return Promise.resolve({
            name: 'asset',
            description: 'Asset Schema for Hub Shakedown',
            display_name: 'Hub Shakedown Schema',
            fields: [
                {
                    name: 'hub_shakedown_name',
                    type: 'string',
                    display_name: 'Hub Shakedown Name',
                    description: 'The name',
                    primary: true
                }
            ]
        });
    }
}
class InvalidDestinationSchemaFunction extends Function {
    async getDestinationsSchema() {
        return {};
    }
}
jest.mock('fs', () => {
    const originalExistsSyncMock = jest.fn();
    return {
        existsSync: originalExistsSyncMock,
        mocks: {
            existsSyncMock: originalExistsSyncMock
        }
    };
});
const mockedModule = jest.requireMock('fs');
const existsSyncMock = mockedModule.mocks.existsSyncMock;
jest.mock('path', () => ({
    ...jest.requireActual('path'),
    join: jest.fn().mockReturnValue('mocked')
}));
describe('validateDestination', () => {
    afterEach(() => {
        jest.clearAllMocks();
    });
    const invalidRuntime = {
        manifest: {
            destinations: {
                validDestination: {
                    entry_point: 'validDestinationClass',
                    schema: 'validSchema'
                },
                missingSchema: {
                    entry_point: 'missingSchemaClass'
                },
                invalidSchema: {
                    entry_point: 'invalidSchemaClass',
                    schema: 123
                }
            }
        },
        getDestinationClass: jest.fn()
    };
    it('should return error when destination cannot be loaded', async () => {
        const getDestinationsClass = jest
            .spyOn(invalidRuntime, 'getDestinationClass')
            .mockRejectedValue(new Error('not found'));
        const result = await (0, validateDestinations_1.validateDestinations)(invalidRuntime);
        getDestinationsClass.mockRestore();
        expect(result).toContain('Error loading entry point validDestination. Error: not found');
    });
    it('should return error when schema is missing', async () => {
        const result = await (0, validateDestinations_1.validateDestinations)(invalidRuntime);
        expect(result).toContain('Destination is missing the schema property: missingSchema');
    });
    it('should return error when schema is not a string or an object', async () => {
        const result = await (0, validateDestinations_1.validateDestinations)(invalidRuntime);
        expect(result).toContain('Destination schema property must be a string or an object: invalidSchema');
    });
    it('should return no error when configuration is valid', async () => {
        const validRuntime = {
            manifest: {
                destinations: {
                    validDestination: {
                        entry_point: 'validDestinationClass',
                        schema: 'validSchema'
                    }
                }
            },
            getDestinationClass: () => ValidDestination
        };
        jest.spyOn(fs_1.default, 'existsSync').mockImplementationOnce(() => true);
        const result = await (0, validateDestinations_1.validateDestinations)(validRuntime);
        expect(result.length).toEqual(0);
    });
    it('should return error when schema is missing', async () => {
        const validRuntime = {
            manifest: {
                destinations: {
                    validDestination: {
                        entry_point: 'validDestinationClass',
                        schema: 'validSchema'
                    }
                }
            },
            getDestinationClass: () => ValidDestination
        };
        existsSyncMock.mockReturnValueOnce(false);
        const result = await (0, validateDestinations_1.validateDestinations)(validRuntime);
        expect(result).toEqual(['File not found for Destination schema validSchema']);
    });
    it('should validate schema entry_point when present', async () => {
        const validRuntime = {
            manifest: {
                destinations: {
                    validDestination: {
                        entry_point: 'validDestinationClass',
                        schema: {
                            entry_point: 'ValidDestinationSchemaFunction'
                        }
                    }
                }
            },
            getDestinationClass: () => ValidDestination,
            getDestinationSchemaFunctionClass: () => ValidDestinationSchemaFunction
        };
        const result = await (0, validateDestinations_1.validateDestinations)(validRuntime);
        expect(result.length).toEqual(0);
    });
    it('should return errors if schema entry_point is not extending the correct interface', async () => {
        const runtime = {
            manifest: {
                destinations: {
                    validDestination: {
                        entry_point: 'validDestinationClass',
                        schema: {
                            entry_point: 'InvalidDestinationSchemaFunction'
                        }
                    }
                }
            },
            getDestinationClass: () => ValidDestination,
            getDestinationSchemaFunctionClass: () => InvalidDestinationSchemaFunction
        };
        const result = await (0, validateDestinations_1.validateDestinations)(runtime);
        expect(result.length).toEqual(1);
        expect(result).toContain('DestinationSchemaFunction entry point does not extend ' +
            'App.DestinationSchemaFunction: InvalidDestinationSchemaFunction');
    });
});
//# sourceMappingURL=validateDestination.test.js.map