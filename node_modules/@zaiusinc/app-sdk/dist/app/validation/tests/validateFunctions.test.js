"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable max-classes-per-file */
const deep_freeze_1 = __importDefault(require("deep-freeze"));
require("jest");
const Function_1 = require("../../Function");
const GlobalFunction_1 = require("../../GlobalFunction");
const Runtime_1 = require("../../Runtime");
const lib_1 = require("../../lib");
const validateFunctions_1 = require("../validateFunctions");
const appManifest = (0, deep_freeze_1.default)({
    meta: {
        app_id: 'my_app',
        display_name: 'My App',
        version: '1.0.0',
        vendor: 'zaius',
        support_url: 'https://zaius.com',
        summary: 'This is an interesting app',
        contact_email: 'support@zaius.com',
        categories: ['Commerce Platform'],
        availability: ['all']
    },
    runtime: 'node12',
    functions: {
        foo: {
            entry_point: 'Foo',
            description: 'gets foo'
        },
        global_foo: {
            entry_point: 'GlobalFoo',
            description: 'gets foo globally',
            global: true
        }
    },
    jobs: {
        bar: {
            entry_point: 'Bar',
            description: 'Does a thing'
        }
    }
});
class NonExtendedFoo {
}
class PartialFoo extends Function_1.Function {
    constructor(request) {
        super(request);
    }
}
class PartialGlobalFoo extends GlobalFunction_1.GlobalFunction {
    constructor(request) {
        super(request);
    }
}
class ProperFoo extends Function_1.Function {
    constructor(request) {
        super(request);
    }
    async perform() {
        return new lib_1.Response();
    }
}
class ProperGlobalFoo extends GlobalFunction_1.GlobalFunction {
    constructor(request) {
        super(request);
    }
    async perform() {
        return new lib_1.Response();
    }
}
describe('validateFunctions', () => {
    it('succeeds with a proper definition', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
        const getFunctionClass = jest
            .spyOn(Runtime_1.Runtime.prototype, 'getFunctionClass')
            .mockImplementation((name) => Promise.resolve(name === 'foo' ? ProperFoo : ProperGlobalFoo));
        const errors = await (0, validateFunctions_1.validateFunctions)(runtime);
        expect(getFunctionClass).toHaveBeenCalledWith('foo');
        expect(getFunctionClass).toHaveBeenCalledWith('global_foo');
        expect(errors).toEqual([]);
        getFunctionClass.mockRestore();
    });
    it('detects missing function entry point', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
        const getFunctionClass = jest
            .spyOn(Runtime_1.Runtime.prototype, 'getFunctionClass')
            .mockRejectedValue(new Runtime_1.FunctionClassNotFoundError('not found'));
        expect(await (0, validateFunctions_1.validateFunctions)(runtime)).toEqual([
            'Error loading function class foo. Error: not found',
            'Error loading function class global_foo. Error: not found'
        ]);
        getFunctionClass.mockRestore();
    });
    it('detects loading errors', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
        const getFunctionClass = jest
            .spyOn(Runtime_1.Runtime.prototype, 'getFunctionClass')
            .mockRejectedValue(new Error('dependent module not found'));
        expect(await (0, validateFunctions_1.validateFunctions)(runtime)).toEqual([
            'Failed to load function class foo.  Error was: dependent module not found'
        ]);
        getFunctionClass.mockRestore();
    });
    it('detects non-extended function entry point', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
        const getFunctionClass = jest.spyOn(Runtime_1.Runtime.prototype, 'getFunctionClass').mockResolvedValue(NonExtendedFoo);
        expect(await (0, validateFunctions_1.validateFunctions)(runtime)).toEqual([
            'Function entry point does not extend App.Function: Foo',
            'Global Function entry point does not extend App.GlobalFunction: GlobalFoo'
        ]);
        getFunctionClass.mockRestore();
    });
    it('detects global functions implementing functions and vis versa', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
        const getFunctionClass = jest
            .spyOn(Runtime_1.Runtime.prototype, 'getFunctionClass')
            .mockImplementation((name) => Promise.resolve(name === 'foo' ? ProperGlobalFoo : ProperFoo));
        expect(await (0, validateFunctions_1.validateFunctions)(runtime)).toEqual([
            'Function entry point does not extend App.Function: Foo',
            'Global Function entry point does not extend App.GlobalFunction: GlobalFoo'
        ]);
        getFunctionClass.mockRestore();
    });
    it('detects partial function entry point', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
        const getFunctionClass = jest
            .spyOn(Runtime_1.Runtime.prototype, 'getFunctionClass')
            .mockImplementation((name) => Promise.resolve(name === 'foo' ? PartialFoo : PartialGlobalFoo));
        expect(await (0, validateFunctions_1.validateFunctions)(runtime)).toEqual([
            'Function entry point is missing the perform method: Foo',
            'Function entry point is missing the perform method: GlobalFoo'
        ]);
        getFunctionClass.mockRestore();
    });
    it('detects global function defining a installation resolution', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
        runtime.manifest.functions.global_foo.installation_resolution = { type: 'HEADER', key: 'foo' };
        const getFunctionClass = jest
            .spyOn(Runtime_1.Runtime.prototype, 'getFunctionClass')
            .mockImplementation((name) => Promise.resolve(name === 'foo' ? ProperFoo : ProperGlobalFoo));
        expect(await (0, validateFunctions_1.validateFunctions)(runtime)).toEqual(['Global functions cannot define a installation_resolution']);
        getFunctionClass.mockRestore();
    });
    it('detects a invalid JSONPath expression', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
        runtime.manifest.functions.foo.installation_resolution = {
            type: 'JSON_BODY_FIELD',
            key: '/test/foo'
        };
        const getFunctionClass = jest
            .spyOn(Runtime_1.Runtime.prototype, 'getFunctionClass')
            .mockImplementation((name) => Promise.resolve(name === 'foo' ? ProperFoo : ProperGlobalFoo));
        expect(await (0, validateFunctions_1.validateFunctions)(runtime)).toEqual([
            'Invalid JSON path expression: Lexical error on line 1. Unrecognized text.\n' + '/test/foo\n' + '^'
        ]);
        getFunctionClass.mockRestore();
    });
});
//# sourceMappingURL=validateFunctions.test.js.map