"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable max-classes-per-file */
const deep_freeze_1 = __importDefault(require("deep-freeze"));
require("jest");
const LiquidExtension_1 = require("../../LiquidExtension");
const Runtime_1 = require("../../Runtime");
const lib_1 = require("../../lib");
const validateLiquidExtensions_1 = require("../validateLiquidExtensions");
const appManifest = (0, deep_freeze_1.default)({
    meta: {
        app_id: 'my_app',
        display_name: 'My App',
        version: '1.0.0',
        vendor: 'zaius',
        support_url: 'https://zaius.com',
        summary: 'This is an interesting app',
        contact_email: 'support@zaius.com',
        categories: ['Commerce Platform'],
        availability: ['all']
    },
    runtime: 'node12',
    functions: {
        foo: {
            entry_point: 'Foo',
            description: 'gets foo'
        }
    },
    jobs: {
        bar: {
            entry_point: 'Bar',
            description: 'Does a thing'
        }
    },
    liquid_extensions: {
        buzz: {
            entry_point: 'Buzz',
            description: 'Buzzes'
        }
    }
});
class NonExtendedBuzz {
}
class PartialBuzz extends LiquidExtension_1.LiquidExtension {
}
class ProperBuzz extends LiquidExtension_1.LiquidExtension {
    async perform() {
        return lib_1.LiquidExtensionResult.success('buzz');
    }
}
describe('validateLiquidExtensions', () => {
    it('succeeds with a proper definition', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
        const getLiquidExtensionClass = jest
            .spyOn(Runtime_1.Runtime.prototype, 'getLiquidExtensionClass')
            .mockResolvedValue(ProperBuzz);
        const errors = await (0, validateLiquidExtensions_1.validateLiquidExtensions)(runtime);
        expect(getLiquidExtensionClass).toHaveBeenCalledWith('buzz');
        expect(errors).toEqual([]);
        getLiquidExtensionClass.mockRestore();
    });
    it('detects missing liquid extension entry point', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
        const getLiquidExtensionClass = jest
            .spyOn(Runtime_1.Runtime.prototype, 'getLiquidExtensionClass')
            .mockRejectedValue(new Error('not found'));
        expect(await (0, validateLiquidExtensions_1.validateLiquidExtensions)(runtime)).toEqual([
            'Error loading entry point for liquid extension buzz. Error: not found'
        ]);
        getLiquidExtensionClass.mockRestore();
    });
    it('detects non-extended liquid extension entry point', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
        const getLiquidExtensionClass = jest
            .spyOn(Runtime_1.Runtime.prototype, 'getLiquidExtensionClass')
            .mockResolvedValue(NonExtendedBuzz);
        expect(await (0, validateLiquidExtensions_1.validateLiquidExtensions)(runtime)).toEqual([
            'Liquid Extension entry point does not extend App.LiquidExtension: Buzz'
        ]);
        getLiquidExtensionClass.mockRestore();
    });
    it('detects partial liquid extension entry point', async () => {
        const runtime = Runtime_1.Runtime.fromJson(JSON.stringify({ appManifest, dirName: '/tmp/foo' }));
        const getLiquidExtensionClass = jest
            .spyOn(Runtime_1.Runtime.prototype, 'getLiquidExtensionClass')
            .mockResolvedValue(PartialBuzz);
        expect(await (0, validateLiquidExtensions_1.validateLiquidExtensions)(runtime)).toEqual([
            'Liquid Extension entry point is missing the perform method: Buzz'
        ]);
        getLiquidExtensionClass.mockRestore();
    });
});
//# sourceMappingURL=validateLiquidExtensions.test.js.map