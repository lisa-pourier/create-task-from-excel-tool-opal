"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceJob = void 0;
class SourceJob {
    invocation;
    source;
    /**
     * Set this to true during an interruptible operation, such as waiting for a long running export.
     * When true, a job can be interrupted and resumed with the PREVIOUS Job state (the one perform was last called with).
     * A job is normally expected to complete a job loop (perform) within < 60s. Your job CAN perform a loop for longer
     * than 60 seconds if isInterruptible is set to true for a significant part of each 60 seconds of runtime
     * and is performing NON-BLOCKING operations.
     * @IMPORTANT You MUST ensure the process is **NOT BLOCKED** while interruptible. This can be achieved
     * by manually calling `await this.sleep()` regularly or is automatic if you are waiting on non-blocking calls.
     *
     * `SourceJob::sleep` and `SourceJob::performInterruptibleTask` will set this value automatically.
     */
    isInterruptible = false;
    /**
     * Initializes a job to be run
     * @param invocation details of the job invocation
     */
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore: 6138 declared but never read
    constructor(invocation, source) {
        this.invocation = invocation;
        this.source = source;
    }
    /**
     * Wrapper for interruptible tasks, such as waiting for a long api call or a timeout loop waiting for a result.
     * Interruptible tasks MUST BE NON-BLOCKING or must manually call `await this.sleep()` regularly (every few seconds).
     * @usage `const result = await this.performInterruptibleTask(() => fetch(...)));`
     * In this example, the job can be interrupted during the fetch operation, and if interrupted will be resumed
     * with the previous job state.
     */
    async performInterruptibleTask(task) {
        const lastInterruptible = this.isInterruptible;
        this.isInterruptible = true;
        try {
            const result = await task();
            this.isInterruptible = lastInterruptible;
            return result;
        }
        catch (e) {
            this.isInterruptible = lastInterruptible;
            throw e;
        }
    }
    /**
     * Sleep the job without CPU thrashing. Use this method to wait for long running tasks, like an export API.
     * @usage `await this.sleep(5000);`
     * @param miliseconds duration to sleep in miliseconds
     * @param options `{interruptible: true}` if the job can be interrupted while sleeping.
     *                A sleep that is not interruptible cannot safely be longer than about 55 seconds.
     */
    async sleep(miliseconds, options) {
        const lastInterruptible = this.isInterruptible;
        if (options?.interruptible !== undefined) {
            this.isInterruptible = !!options.interruptible;
        }
        // perform the sleep
        await new Promise((resolve) => setTimeout(resolve, miliseconds || 0));
        this.isInterruptible = lastInterruptible;
    }
}
exports.SourceJob = SourceJob;
//# sourceMappingURL=SourceJob.js.map