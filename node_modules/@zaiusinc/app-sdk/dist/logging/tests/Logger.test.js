"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const async_hooks_1 = require("async_hooks");
require("jest");
const Logger_1 = require("../Logger");
describe('Logger', () => {
    function runWithAsyncLocalStore(code, logLevel = Logger_1.LogLevel.Info, logContext = null) {
        const ocpContextStorage = new async_hooks_1.AsyncLocalStorage();
        global.ocpContextStorage = ocpContextStorage;
        const context = {
            ocpRuntime: {
                logLevel,
                logContext
            }
        };
        ocpContextStorage.run(context, code);
    }
    beforeAll(() => {
        jest.spyOn(process.stdout, 'write');
        jest.spyOn(process.stderr, 'write');
    });
    beforeEach(() => {
        jest.resetAllMocks();
    });
    afterAll(() => {
        jest.restoreAllMocks();
    });
    describe('constructor - async local store', () => {
        it('defaults to developer visibility', () => {
            const logFn = jest.spyOn(Logger_1.logger, 'log');
            runWithAsyncLocalStore(async () => {
                Logger_1.logger.info('info');
                expect(logFn).toHaveBeenCalledWith(Logger_1.LogLevel.Info, Logger_1.LogVisibility.Developer, 'info');
            });
            logFn.mockRestore();
        });
        it('sets the default visibility', () => {
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger({ defaultVisibility: Logger_1.LogVisibility.Zaius }).info('info');
                expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ audience: 'zaius' }));
            });
        });
        it('uses the provided log context', () => {
            runWithAsyncLocalStore(async () => {
                Logger_1.logger.info('info');
                expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({
                    context: {
                        app_id: 'sample',
                        app_version: '1.0.0',
                        tracker_id: 'vdl',
                        install_id: 1234,
                        entry_point: 'job:foo',
                        job_id: '123-456'
                    }
                }));
            }, Logger_1.LogLevel.Info, {
                app_id: 'sample',
                app_version: '1.0.0',
                tracker_id: 'vdl',
                install_id: 1234,
                entry_point: 'job:foo',
                job_id: '123-456'
            });
        });
    });
    describe('debug - async local store', () => {
        it('logs to stdout', () => {
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger().debug('debug');
                expect(process.stdout.write).toHaveBeenCalledTimes(1);
                expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ message: 'debug' }));
            }, Logger_1.LogLevel.Debug);
        });
        it('does nothing if log level > debug', () => {
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger().debug('debug');
            }, Logger_1.LogLevel.Warn);
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger().debug('debug');
            }, Logger_1.LogLevel.Info);
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger().debug('debug');
            }, Logger_1.LogLevel.Error);
            expect(process.stdout.write).not.toHaveBeenCalled();
        });
        it('sets the log level to debug on the log', () => {
            runWithAsyncLocalStore(async () => {
                Logger_1.logger.debug('level check');
                expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ level: 'debug' }));
            }, Logger_1.LogLevel.Debug);
        });
        it('respects visibility', () => {
            runWithAsyncLocalStore(async () => {
                Logger_1.logger.debug(Logger_1.LogVisibility.Zaius, 'check check');
                expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ audience: 'zaius' }));
            }, Logger_1.LogLevel.Debug);
        });
    });
    describe('info - async local store', () => {
        it('logs to stdout when the log level is <= info', () => {
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger().info('debug');
            });
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger().info('info');
            }, Logger_1.LogLevel.Info);
            expect(process.stdout.write).toHaveBeenCalledTimes(2);
            expect(process.stdout.write).toHaveBeenNthCalledWith(1, expect.jsonContaining({ message: 'debug' }));
            expect(process.stdout.write).toHaveBeenNthCalledWith(2, expect.jsonContaining({ message: 'info' }));
        });
        it('does nothing if log level > info', () => {
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger().info('info');
            }, Logger_1.LogLevel.Warn);
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger().info('info');
            }, Logger_1.LogLevel.Error);
            expect(process.stdout.write).not.toHaveBeenCalled();
        });
        it('sets the log level to info on the log', () => {
            runWithAsyncLocalStore(async () => {
                Logger_1.logger.info('level check');
                expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ level: 'info' }));
            });
        });
        it('respects visibility', () => {
            runWithAsyncLocalStore(async () => {
                Logger_1.logger.info(Logger_1.LogVisibility.Zaius, 'check check');
                expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ audience: 'zaius' }));
            });
        });
    });
    describe('warn - async local store', () => {
        it('logs to stdout when the log level is <= warn', () => {
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger().warn('debug');
            }, Logger_1.LogLevel.Debug);
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger().warn('info');
            }, Logger_1.LogLevel.Info);
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger().warn('warn');
            }, Logger_1.LogLevel.Warn);
            expect(process.stdout.write).toHaveBeenCalledTimes(3);
            expect(process.stdout.write).toHaveBeenNthCalledWith(1, expect.jsonContaining({ message: 'debug' }));
            expect(process.stdout.write).toHaveBeenNthCalledWith(2, expect.jsonContaining({ message: 'info' }));
            expect(process.stdout.write).toHaveBeenNthCalledWith(3, expect.jsonContaining({ message: 'warn' }));
        });
        it('does nothing if log level > warn', () => {
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger().warn('warn');
                expect(process.stdout.write).not.toHaveBeenCalled();
            }, Logger_1.LogLevel.Error);
        });
        it('sets the log level to warn on the log', () => {
            runWithAsyncLocalStore(async () => {
                Logger_1.logger.warn('level check');
                expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ level: 'warn' }));
            });
        });
        it('respects visibility', () => {
            runWithAsyncLocalStore(async () => {
                Logger_1.logger.warn(Logger_1.LogVisibility.Zaius, 'check check');
                expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ audience: 'zaius' }));
            });
        });
    });
    describe('error - async local store', () => {
        it('logs to stderr', () => {
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger().error('debug');
            }, Logger_1.LogLevel.Debug);
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger().error('info');
            }, Logger_1.LogLevel.Info);
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger().error('warn');
            }, Logger_1.LogLevel.Warn);
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger().error('error');
            }, Logger_1.LogLevel.Error);
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger().error('never'); // suppresses log
            }, Logger_1.LogLevel.NEVER);
            expect(process.stderr.write).toHaveBeenCalledTimes(4);
            expect(process.stderr.write).toHaveBeenNthCalledWith(1, expect.jsonContaining({ message: 'debug' }));
            expect(process.stderr.write).toHaveBeenNthCalledWith(2, expect.jsonContaining({ message: 'info' }));
            expect(process.stderr.write).toHaveBeenNthCalledWith(3, expect.jsonContaining({ message: 'warn' }));
            expect(process.stderr.write).toHaveBeenNthCalledWith(4, expect.jsonContaining({ message: 'error' }));
        });
        it('logs even if log level is error', () => {
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger().error('error');
                expect(process.stderr.write).toHaveBeenCalledWith(expect.jsonContaining({ message: 'error' }));
            }, Logger_1.LogLevel.Error);
        });
        it('sets the log level to info on the log', () => {
            runWithAsyncLocalStore(async () => {
                Logger_1.logger.error('level check');
                expect(process.stderr.write).toHaveBeenCalledWith(expect.jsonContaining({ level: 'error' }));
            });
        });
        it('respects visibility', () => {
            runWithAsyncLocalStore(async () => {
                Logger_1.logger.error(Logger_1.LogVisibility.Zaius, 'check check');
                expect(process.stderr.write).toHaveBeenCalledWith(expect.jsonContaining({ audience: 'zaius' }));
            });
        });
    });
    describe('log - async local store', () => {
        it('formats objects', () => {
            runWithAsyncLocalStore(async () => {
                Logger_1.logger.info({ foo: [1, { bar: 'bar' }] });
                expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ message: "{ foo: [ 1, { bar: 'bar' } ] }" }));
            });
        });
        it('extracts the stacktrace from the first error', () => {
            runWithAsyncLocalStore(async () => {
                Logger_1.logger.error(new Error('i have a stacktrace'));
                expect(process.stderr.write).toHaveBeenCalledWith(expect.stringMatching(/"stacktrace":".+"/));
                Logger_1.logger.error('Error:', new Error('i have a stacktrace'));
                expect(process.stderr.write).toHaveBeenCalledWith(expect.stringMatching(/"stacktrace":".+"/));
                Logger_1.logger.error('no stacktrace');
                expect(process.stderr.write).toHaveBeenCalledWith(expect.not.stringMatching(/"stacktrace":".+"/));
            });
        });
        it('concatenates different values logged in one call', () => {
            runWithAsyncLocalStore(async () => {
                Logger_1.logger.error('!!!', new Error('something went wrong'), 5, 'times');
                expect(process.stderr.write).toHaveBeenCalledWith(expect.jsonContaining({ message: '!!! Error: something went wrong 5 times' }));
            });
        });
        it('fills in all the expected details', () => {
            jest.spyOn(Date.prototype, 'toISOString').mockReturnValueOnce('2019-09-04T19:49:22.275Z');
            runWithAsyncLocalStore(async () => {
                Logger_1.logger.info('This is a test');
                expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonRepresenting({
                    time: '2019-09-04T19:49:22.275Z',
                    level: 'info',
                    message: 'This is a test',
                    audience: 'developer',
                    context: {
                        app_id: 'sample1',
                        app_version: '1.1.0',
                        tracker_id: 'abc123',
                        install_id: 123,
                        entry_point: 'function:foo',
                        request_id: '12345-678-90'
                    }
                }));
            }, Logger_1.LogLevel.Info, {
                app_id: 'sample1',
                app_version: '1.1.0',
                tracker_id: 'abc123',
                install_id: 123,
                entry_point: 'function:foo',
                request_id: '12345-678-90'
            });
        });
        it.each([
            ['a'.repeat(15), 'a'.repeat(15)],
            ['a'.repeat(16), 'a'.repeat(16)],
            ['a'.repeat(17), 'a'.repeat(13) + '...'],
            ['a'.repeat(18), 'a'.repeat(13) + '...']
        ])('truncates long messages', (input, expected) => {
            runWithAsyncLocalStore(async () => {
                new Logger_1.Logger({ maxLineLength: 16 }).info(input);
                expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ message: expected }));
            });
        });
    });
    describe('override default log level - async local store', () => {
        it('logs to stdout only logs with level >= overriden log level ', () => {
            jest.spyOn(Date.prototype, 'toISOString').mockReturnValueOnce('2019-09-04T19:49:22.275Z');
            runWithAsyncLocalStore(async () => {
                Logger_1.logger.debug('debug');
                Logger_1.logger.info('info');
                Logger_1.logger.warn('warn');
                Logger_1.logger.error('error');
                expect(process.stdout.write).toHaveBeenCalledTimes(1);
                expect(process.stdout.write).toHaveBeenNthCalledWith(1, expect.jsonContaining({ message: 'warn' }));
                expect(process.stderr.write).toHaveBeenCalledTimes(1);
                expect(process.stderr.write).toHaveBeenNthCalledWith(1, expect.jsonContaining({ message: 'error' }));
            }, Logger_1.LogLevel.Warn);
        });
        it('does nothing if the overridden log level < overridden log level', () => {
            jest.spyOn(Date.prototype, 'toISOString').mockReturnValueOnce('2019-09-04T19:49:22.275Z');
            runWithAsyncLocalStore(async () => {
                Logger_1.logger.debug('debug');
                Logger_1.logger.info('info');
                expect(process.stdout.write).not.toHaveBeenCalled();
            }, Logger_1.LogLevel.Warn);
        });
    });
    describe('constructor - module scope', () => {
        it('defaults to developer visibility', () => {
            const logFn = jest.spyOn(Logger_1.logger, 'log');
            Logger_1.logger.info('info');
            expect(logFn).toHaveBeenCalledWith(Logger_1.LogLevel.Info, Logger_1.LogVisibility.Developer, 'info');
            logFn.mockRestore();
        });
        it('sets the default visibility', () => {
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Info);
            new Logger_1.Logger({ defaultVisibility: Logger_1.LogVisibility.Zaius }).info('info');
            expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ audience: 'zaius' }));
        });
        it('uses the provided log context', () => {
            (0, Logger_1.setLogContext)({
                app_id: 'sample',
                app_version: '1.0.0',
                tracker_id: 'vdl',
                install_id: 1234,
                entry_point: 'job:foo',
                job_id: '123-456'
            });
            (0, Logger_1.amendLogContext)({ extra_field: 'extra_value' });
            Logger_1.logger.info('info');
            expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({
                context: {
                    app_id: 'sample',
                    app_version: '1.0.0',
                    tracker_id: 'vdl',
                    install_id: 1234,
                    entry_point: 'job:foo',
                    job_id: '123-456',
                    extra_field: 'extra_value'
                }
            }));
        });
    });
    describe('debug - module scope', () => {
        it('logs to stdout', () => {
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Debug);
            new Logger_1.Logger({}).debug('debug');
            expect(process.stdout.write).toHaveBeenCalledTimes(1);
            expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ message: 'debug' }));
        });
        it('does nothing if log level > debug', () => {
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Warn);
            new Logger_1.Logger().debug('debug');
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Info);
            new Logger_1.Logger().debug('debug');
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Error);
            new Logger_1.Logger().debug('debug');
            expect(process.stdout.write).not.toHaveBeenCalled();
        });
        it('sets the log level to debug on the log', () => {
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Debug);
            Logger_1.logger.debug('level check');
            expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ level: 'debug' }));
        });
        it('respects visibility', () => {
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Debug);
            Logger_1.logger.debug(Logger_1.LogVisibility.Zaius, 'check check');
            expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ audience: 'zaius' }));
        });
    });
    describe('info - module scope', () => {
        beforeEach(() => {
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Info);
        });
        it('logs to stdout when the log level is <= info', () => {
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Debug);
            new Logger_1.Logger({}).info('debug');
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Info);
            new Logger_1.Logger({}).info('info');
            expect(process.stdout.write).toHaveBeenCalledTimes(2);
            expect(process.stdout.write).toHaveBeenNthCalledWith(1, expect.jsonContaining({ message: 'debug' }));
            expect(process.stdout.write).toHaveBeenNthCalledWith(2, expect.jsonContaining({ message: 'info' }));
        });
        it('does nothing if log level > info', () => {
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Warn);
            new Logger_1.Logger({}).info('info');
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Error);
            new Logger_1.Logger({}).info('info');
            expect(process.stdout.write).not.toHaveBeenCalled();
        });
        it('sets the log level to info on the log', () => {
            Logger_1.logger.info('level check');
            expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ level: 'info' }));
        });
        it('respects visibility', () => {
            Logger_1.logger.info(Logger_1.LogVisibility.Zaius, 'check check');
            expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ audience: 'zaius' }));
        });
    });
    describe('warn - module scope', () => {
        beforeEach(() => {
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Warn);
        });
        it('logs to stdout when the log level is <= warn', () => {
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Debug);
            new Logger_1.Logger({}).warn('debug');
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Info);
            new Logger_1.Logger({}).warn('info');
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Warn);
            new Logger_1.Logger({}).warn('warn');
            expect(process.stdout.write).toHaveBeenCalledTimes(3);
            expect(process.stdout.write).toHaveBeenNthCalledWith(1, expect.jsonContaining({ message: 'debug' }));
            expect(process.stdout.write).toHaveBeenNthCalledWith(2, expect.jsonContaining({ message: 'info' }));
            expect(process.stdout.write).toHaveBeenNthCalledWith(3, expect.jsonContaining({ message: 'warn' }));
        });
        it('does nothing if log level > warn', () => {
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Error);
            new Logger_1.Logger({}).warn('warn');
            expect(process.stdout.write).not.toHaveBeenCalled();
        });
        it('sets the log level to warn on the log', () => {
            Logger_1.logger.warn('level check');
            expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ level: 'warn' }));
        });
        it('respects visibility', () => {
            Logger_1.logger.warn(Logger_1.LogVisibility.Zaius, 'check check');
            expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ audience: 'zaius' }));
        });
    });
    describe('error - module scope', () => {
        beforeEach(() => {
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Error);
        });
        it('logs to stderr', () => {
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Debug);
            new Logger_1.Logger({}).error('debug');
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Info);
            new Logger_1.Logger({}).error('info');
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Warn);
            new Logger_1.Logger({}).error('warn');
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Error);
            new Logger_1.Logger({}).error('error');
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.NEVER);
            new Logger_1.Logger({}).error('never'); // suppresses log
            expect(process.stderr.write).toHaveBeenCalledTimes(4);
            expect(process.stderr.write).toHaveBeenNthCalledWith(1, expect.jsonContaining({ message: 'debug' }));
            expect(process.stderr.write).toHaveBeenNthCalledWith(2, expect.jsonContaining({ message: 'info' }));
            expect(process.stderr.write).toHaveBeenNthCalledWith(3, expect.jsonContaining({ message: 'warn' }));
            expect(process.stderr.write).toHaveBeenNthCalledWith(4, expect.jsonContaining({ message: 'error' }));
        });
        it('logs even if log level is error', () => {
            new Logger_1.Logger({}).error('error');
            expect(process.stderr.write).toHaveBeenCalledWith(expect.jsonContaining({ message: 'error' }));
        });
        it('sets the log level to info on the log', () => {
            Logger_1.logger.error('level check');
            expect(process.stderr.write).toHaveBeenCalledWith(expect.jsonContaining({ level: 'error' }));
        });
        it('respects visibility', () => {
            Logger_1.logger.error(Logger_1.LogVisibility.Zaius, 'check check');
            expect(process.stderr.write).toHaveBeenCalledWith(expect.jsonContaining({ audience: 'zaius' }));
        });
    });
    describe('log - module scope', () => {
        beforeEach(() => {
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Info);
        });
        it('formats objects', () => {
            Logger_1.logger.info({ foo: [1, { bar: 'bar' }] });
            expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ message: "{ foo: [ 1, { bar: 'bar' } ] }" }));
        });
        it('extracts the stacktrace from the first error', () => {
            Logger_1.logger.error(new Error('i have a stacktrace'));
            expect(process.stderr.write).toHaveBeenCalledWith(expect.stringMatching(/"stacktrace":".+"/));
            Logger_1.logger.error('Error:', new Error('i have a stacktrace'));
            expect(process.stderr.write).toHaveBeenCalledWith(expect.stringMatching(/"stacktrace":".+"/));
            Logger_1.logger.error('no stacktrace');
            expect(process.stderr.write).toHaveBeenCalledWith(expect.not.stringMatching(/"stacktrace":".+"/));
        });
        it('concatenates different values logged in one call', () => {
            Logger_1.logger.error('!!!', new Error('something went wrong'), 5, 'times');
            expect(process.stderr.write).toHaveBeenCalledWith(expect.jsonContaining({ message: '!!! Error: something went wrong 5 times' }));
        });
        it('fills in all the expected details', () => {
            (0, Logger_1.setLogContext)({
                app_id: 'sample1',
                app_version: '1.1.0',
                tracker_id: 'abc123',
                install_id: 123,
                entry_point: 'function:foo',
                request_id: '12345-678-90'
            });
            (0, Logger_1.amendLogContext)({ extra_field: 'extra_value' });
            jest.spyOn(Date.prototype, 'toISOString').mockReturnValueOnce('2019-09-04T19:49:22.275Z');
            Logger_1.logger.info('This is a test');
            expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonRepresenting({
                time: '2019-09-04T19:49:22.275Z',
                level: 'info',
                message: 'This is a test',
                audience: 'developer',
                context: {
                    app_id: 'sample1',
                    app_version: '1.1.0',
                    tracker_id: 'abc123',
                    install_id: 123,
                    entry_point: 'function:foo',
                    request_id: '12345-678-90',
                    extra_field: 'extra_value'
                }
            }));
        });
        it.each([
            ['a'.repeat(15), 'a'.repeat(15)],
            ['a'.repeat(16), 'a'.repeat(16)],
            ['a'.repeat(17), 'a'.repeat(13) + '...'],
            ['a'.repeat(18), 'a'.repeat(13) + '...']
        ])('truncates long messages', (input, expected) => {
            new Logger_1.Logger({ maxLineLength: 16 }).info(input);
            expect(process.stdout.write).toHaveBeenCalledWith(expect.jsonContaining({ message: expected }));
        });
    });
    describe('override default log level - module scope', () => {
        it('logs to stdout only logs with level >= overriden log level ', () => {
            jest.spyOn(Date.prototype, 'toISOString').mockReturnValueOnce('2019-09-04T19:49:22.275Z');
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Warn);
            Logger_1.logger.debug('debug');
            Logger_1.logger.info('info');
            Logger_1.logger.warn('warn');
            Logger_1.logger.error('error');
            expect(process.stdout.write).toHaveBeenCalledTimes(1);
            expect(process.stdout.write).toHaveBeenNthCalledWith(1, expect.jsonContaining({ message: 'warn' }));
            expect(process.stderr.write).toHaveBeenCalledTimes(1);
            expect(process.stderr.write).toHaveBeenNthCalledWith(1, expect.jsonContaining({ message: 'error' }));
        });
        it('does nothing if the overridden log level < overridden log level', () => {
            jest.spyOn(Date.prototype, 'toISOString').mockReturnValueOnce('2019-09-04T19:49:22.275Z');
            (0, Logger_1.setLogLevel)(Logger_1.LogLevel.Warn);
            Logger_1.logger.debug('debug');
            Logger_1.logger.info('info');
            expect(process.stdout.write).not.toHaveBeenCalled();
        });
    });
});
//# sourceMappingURL=Logger.test.js.map