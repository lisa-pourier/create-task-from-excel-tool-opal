import 'jest';
import {ElementType, TextField} from '../elements';
import {Form} from '../Form';
import {Evaluation, Predicate, Schema} from '../index';
import {validateFormDefinition} from './validateForm';

describe('validateFormDefinition', () => {
  it('succeeds with valid form definition', async () => {
    const validForm = {
      sections: [
        {
          key: 'auth',
          label: 'Authentication',
          properties: ['valid', 'authThing'],
          elements: [
            {
              type: ElementType.Text,
              key: 'email',
              label: 'Email',
              help: 'Your MonkeyMailer login',
              hint: 'user@domain.com',
              dataType: 'email',
              validations: [
                {
                  regex: '/[^@]+@[^\\.]+\\..+/',
                  message: 'Please enter your email you use to log in to MonkeyMailer.'
                }
              ],
              visible: {
                key: 'authThing',
                equals: true
              }
            },
            {
              type: ElementType.Secret,
              key: 'secret',
              label: 'Secret',
              help: 'Your MonkeyMailer API secret',
              validations: [
                {
                  regex: '/^[a-z0-9]{13,}/i',
                  message:
                    'Your API secret does not appear to be valid. ' +
                    'It can be found on your MonkeyMailer admin page under Integrations > API.'
                }
              ]
            },
            {
              type: Schema.ElementType.Button,
              label: 'Login',
              action: 'login',
              disabled: {
                operation: 'any',
                comparators: [
                  {key: 'email', empty: true},
                  {key: 'auth.secret', empty: true}
                ]
              }
            }
          ]
        }
      ]
    };

    expect(await validateFormDefinition(validForm as any)).toEqual([]);
  });

  it('does not fail an empty form', async () => {
    const validForm = {
      sections: [
        {
          key: 'auth',
          label: 'Authentication',
          properties: ['valid'],
          elements: []
        }
      ]
    };

    expect(await validateFormDefinition(validForm)).toEqual([]);
  });

  it('validates json schema for form', async () => {
    const invalidForm = {
      sections: [
        {
          key: 'auth',
          properties: ['valid'],
          elements: [
            {
              type: Schema.ElementType.Button,
              label: 'Login'
            },
            {
              type: 'widget',
              label: 'Howdy!'
            }
          ]
        }
      ]
    };

    expect(await validateFormDefinition(invalidForm as any)).toEqual([
      "sections[0] must have required property 'label'",
      "sections[0].elements[0] must have required property 'action'",
      'sections[0].elements[1].type must be equal to one of the allowed values'
    ]);
  });

  it('validates regexes', async () => {
    const form = {
      sections: [
        {
          key: 'auth',
          label: 'Authentication',
          properties: ['valid'],
          elements: [
            {
              type: ElementType.Text,
              key: 'email',
              label: 'Email',
              help: 'Your MonkeyMailer login',
              hint: 'user@domain.com',
              dataType: 'email',
              validations: [
                {
                  regex: '[*',
                  flags: 'flubadub',
                  message: 'Please enter your email you use to log in to MonkeyMailer.'
                }
              ]
            }
          ]
        }
      ]
    };

    expect(await validateFormDefinition(form as any)).toEqual([
      'Invalid regex at sections[0].elements[0].validations[0].regex',
      'Invalid regex flags at sections[0].elements[0].validations[0].flags'
    ]);
  });

  it('validates a form with a ZedSection', async () => {
    const invalidForm = {
      sections: [
        {
          key: 'zedSection',
          label: 'Message',
          type: 'zed',
          mode: 'email'
        },
        {
          key: 'regularSection',
          label: 'Regular Section',
          type: 'form',
          elements: [{
            type: ElementType.Text,
            key: 'email',
            label: 'Email',
            help: 'Your Email',
            hint: 'user@domain.com',
            dataType: 'email',
          }]
        }
      ]
    };

    expect(await validateFormDefinition(invalidForm as any)).toEqual([]);
  });

  describe('validates data', () => {
    const generateForm = (evaluation: Evaluation) => {
      const element = {
        type: ElementType.Text,
        key: 'foo',
        label: 'Foo',
        help: 'Your Foo',
        dataType: 'text',
        disabled: evaluation,
        visible: evaluation
      } as TextField;

      if ('comparators' in (evaluation as any)) {
        const predicate = evaluation as Predicate;
        element.validations = [
          {
            predicate,
            message: 'Invalid'
          }
        ];
      }

      return {
        sections: [
          {
            key: 'auth',
            label: 'Authentication',
            properties: ['valid'],
            visible: evaluation,
            disabled: evaluation,
            elements: [element]
          }
        ]
      };
    };

    it('detects missing keys from comparators', async () => {
      const badComparator = {
        key: 'auth.bar',
        equals: true
      } as Schema.Comparator;

      const form = generateForm(badComparator);
      expect(await validateFormDefinition(form as any)).toEqual([
        "sections[0].visible references undefined data key 'auth.bar'",
        "sections[0].disabled references undefined data key 'auth.bar'",
        "sections[0].elements[0].disabled references undefined data key 'auth.bar'",
        "sections[0].elements[0].visible references undefined data key 'auth.bar'"
      ]);
    });

    it('detects missing non-namespaced keys from comparators', async () => {
      const badComparator = {
        key: 'bar',
        equals: true
      } as Schema.Comparator;

      const form = generateForm(badComparator);
      expect(await validateFormDefinition(form as any)).toEqual([
        "sections[0].visible references undefined data key 'bar'",
        "sections[0].disabled references undefined data key 'bar'",
        "sections[0].elements[0].disabled references undefined data key 'bar'",
        "sections[0].elements[0].visible references undefined data key 'bar'"
      ]);
    });

    it('detects missing keys from other sections from comparators', async () => {
      const badComparator = {
        key: 'foo.bar',
        equals: true
      } as Schema.Comparator;

      const form = generateForm(badComparator);
      expect(await validateFormDefinition(form as any)).toEqual([
        "sections[0].visible references undefined data key 'foo.bar'",
        "sections[0].disabled references undefined data key 'foo.bar'",
        "sections[0].elements[0].disabled references undefined data key 'foo.bar'",
        "sections[0].elements[0].visible references undefined data key 'foo.bar'"
      ]);
    });

    it('detects missing keys from predicates', async () => {
      const badPredicate = {
        operation: 'any',
        comparators: [
          {key: 'bar', empty: true},
          {key: 'baz.bam', empty: true}
        ]
      } as Schema.Predicate;

      const form = generateForm(badPredicate);
      expect(await validateFormDefinition(form as any)).toEqual([
        "sections[0].visible.comparators[0] references undefined data key 'bar'",
        "sections[0].visible.comparators[1] references undefined data key 'baz.bam'",
        "sections[0].disabled.comparators[0] references undefined data key 'bar'",
        "sections[0].disabled.comparators[1] references undefined data key 'baz.bam'",
        "sections[0].elements[0].disabled.comparators[0] references undefined data key 'bar'",
        "sections[0].elements[0].disabled.comparators[1] references undefined data key 'baz.bam'",
        "sections[0].elements[0].visible.comparators[0] references undefined data key 'bar'",
        "sections[0].elements[0].visible.comparators[1] references undefined data key 'baz.bam'",
        "sections[0].elements[0].validations[0].predicate.comparators[0] references undefined data key 'bar'",
        "sections[0].elements[0].validations[0].predicate.comparators[1] references undefined data key 'baz.bam'"
      ]);
    });

    it('detects missing keys in mustache', async () => {
      const invalidForm: Form = {
        sections: [
          {
            key: 's1',
            label: 'Section {{{s1.name}}}',
            properties: ['name'],
            elements: [{
              type: ElementType.Instructions,
              text: 'The name is {{{name}}}' // not fully qualified
            }]
          },
          {
            key: 's2',
            label: 'Section 2 {{s1.F_o_o}}}', // s1.F_o_o does not exist
            elements: [{
              type: ElementType.Text,
              key: 'url',
              label: 'URL',
              help: 'Your Website URL for {{s1.name0}}', // s1.name0 does not exist
              hint: 'https://foo.bar'
            }, {
              type: ElementType.LinkButton,
              label: 'Visit {{{s2.url}}}',
              help: 'Preview your {{{s1.name}}} website {{#s2.foo}}(foo){{/s2.foo}}', // s2.foo does not exist
              href: '{{{ s2.url }}}{{^ s2.url }}{{{s1.foo}}}{{/url}}' // s1.foo does not exist, url not fully qualified
            }]
          }
        ]
      };

      expect(await validateFormDefinition(invalidForm as any)).toEqual([
        "sections[0].elements[0].text references undefined data key 'name'",
        "sections[1].label references undefined data key 's1.F_o_o'",
        "sections[1].elements[0].help references undefined data key 's1.name0'",
        "sections[1].elements[1].help references undefined data key 's2.foo'",
        "sections[1].elements[1].href references undefined data key 's1.foo'",
        "sections[1].elements[1].href references undefined data key 'url'",
      ]);
    });

    it('detects missing keys in a a ZedSection', async () => {
      const invalidForm = {
        sections: [
          {
            type: 'zed',
            elements: ['extra']
          },
          {
            key: 'regularSection',
            label: 'Regular Section',
            type: 'form',
            elements: [{
              type: ElementType.Text,
              key: 'email',
              label: 'Email',
              help: 'Your Email',
              hint: 'user@domain.com',
              dataType: 'email',
            }]
          }
        ]
      };

      expect(await validateFormDefinition(invalidForm as any)).toEqual([
        "sections[0] must have required property 'key'",
        "sections[0] must have required property 'label'",
        "sections[0] must have required property 'mode'",
        'sections[0] must NOT have additional properties'
      ]);
    });
  });
});
