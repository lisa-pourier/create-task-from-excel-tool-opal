import Ajv from 'ajv';
import {ErrorObject} from 'ajv';
import {Comparator, FieldValidation, Predicate, RegexComparator} from '../evaluations';
import {AnyElement, FormElement, Schema} from '../index';
import formSchema from '../schema/Form.schema.json';
import formRootSchema from '../schema/FormRoot.schema.json';
import {Section, SectionType} from '../Section';
import {ZedSection} from '../ZedSection';

interface DataRef {
  path: string;
  key: string;
}

interface RegexRef {
  path: string;
  regex: string;
  flags?: string;
}

type TraversableFormItem =
  | Section
  | ZedSection
  | AnyElement
  | Comparator
  | Predicate
  | FieldValidation
  | AnyElement[]
  | Comparator[]
  | Predicate[]
  | FieldValidation[];

export async function validateFormDefinition(form: Schema.Form): Promise<string[]> {
  const errors: string[] = [];
  const ajv = new Ajv({allErrors: true, allowUnionTypes: true});

  if (!ajv.validate(formRootSchema, form)) {
    (ajv.errors ?? []).forEach((e) => errors.push(formatAjvError(e)));
  }
  if (Array.isArray(form.sections)) {
    for (let i = 0; i < form.sections.length; i++) {
      const section = form.sections[i];
      errors.push(...await validateSection(section, `sections[${i}]`, ajv));
    }
  }
  if (errors.length === 0) {
    const dataKeys: Set<string> = new Set<string>();
    const unvalidatedDataRefs: DataRef[] = [];

    form.sections.forEach((section, sectionIndex) => {
      const sectionDataKeys: Set<string> = new Set<string>();
      const addSectionDataKey = (key: string) => {
        const dataKey = `${section.key}.${key}`;
        dataKeys.add(dataKey);
        if (sectionDataKeys.has(dataKey)) {
          errors.push(`data key ${dataKey} is defined more than once`);
        } else {
          sectionDataKeys.add(dataKey);
        }
      };

      if (isFormSection(section)) {
        if (section.properties) {
          for (const property of section.properties) {
            addSectionDataKey(property);
          }
        }

        unvalidatedDataRefs.push(...eachMustacheRef(section, `sections[${sectionIndex}]`));

        let i = 0;
        for (const element of section.elements) {
          if (element.key) {
            addSectionDataKey(element.key);
          }

          // verify all mustache references are valid (and fully qualified)
          unvalidatedDataRefs.push(...eachMustacheRef(element, `sections[${sectionIndex}].elements[${i}]`));

          i++;
        }
      }

      // verify all key references in predicates are valid
      for (const ref of traverseForm(section, `sections[${sectionIndex}]`)) {
        if (isDataRef(ref)) {
          if (!sectionDataKeys.has(qualifyKey(section, ref.key))) {
            unvalidatedDataRefs.push(ref);
          }
        } else {
          errors.push(...validateRegex(ref));
        }
      }
    });

    for (const ref of unvalidatedDataRefs) {
      if (!dataKeys.has(ref.key)) {
        errors.push(`${ref.path} references undefined data key '${ref.key}'`);
      }
    }
  }

  // Deduplicate the error messages
  return errors.filter((e, i) => i === errors.indexOf(e));
}

function isFormSection(section: Section | ZedSection): section is Section {
  return (section.type ?? SectionType.Form) === SectionType.Form;
}

export async function validateSection(section: Section | ZedSection, path: string, ajv: Ajv): Promise<string[]> {
  const type = isFormSection(section) ? 'Section' : 'ZedSection';
  // reconfigure the schema to only validate the section
  ajv.validate({
    '$schema': formSchema.$schema,
    definitions: formSchema.definitions,
    ...formSchema.definitions[type]
  }, section);
  return (ajv.errors || [])
    .map((e: ErrorObject) => formatAjvError(e, path))
    .filter((e: string) => !e.includes('"then"'));
}

function formatAjvError(e: ErrorObject, basePath?: string): string {
  let adjustedDataPath = e.instancePath.length > 0 ?
    e.instancePath
      .substring(1)
      .replace(/\//g, '.').replace(/\.(\d+)/g, '[$1]')
      .replace(/\['([^']+)']/, '.$1') + ' ' : '';
  if (basePath) {
    adjustedDataPath = adjustedDataPath.length > 0 ? `${basePath}.${adjustedDataPath}` : basePath + ' ';
  }
  return `${adjustedDataPath}${e.message?.replace(/\bshould\b/, 'must') ?? ''}`;
}

function* traverseForm(item: TraversableFormItem, path: string): IterableIterator<DataRef | RegexRef> {
  if (Array.isArray(item)) {
    for (let i = 0; i < item.length; i++) {
      yield* traverseForm(item[i], `${path}[${i}]`);
    }
  } else if (typeof item === 'object') {
    if (isComparator(item) && item.key) {
      yield {path, key: item.key};
    }

    for (const key of Object.keys(item)) {
      const val = (item as any)[key];

      if (isRegexComparator(item)) {
        yield {path, regex: val, flags: item['flags']};
      } else {
        yield* traverseForm(val, `${path}.${key}`);
      }
    }
  }
}

function* eachMustacheRef(element: Section | FormElement | any, path: string): IterableIterator<DataRef>  {
  for (const prop of ['label', 'help', 'text', 'href']) {
    if (element[prop]) {
      const mustacheRegex = /\{\{[#/^>{]?\s*([\w\d_.]+)\s*}}/gi;
      let m: RegExpExecArray | null;
      do {
        m = mustacheRegex.exec(element[prop]);
        if (m) {
          yield {path: `${path}.${prop}`, key: m[1]};
        }
      } while (m);
    }
  }
}

function qualifyKey(section: Section | ZedSection, key: string): string {
  return key.startsWith(section.key + '.') ? key : `${section.key}.${key}`;
}

function isDataRef(ref: DataRef | RegexRef): ref is DataRef {
  return 'key' in ref && typeof ref.key === 'string';
}

function isComparator(item: any): item is Comparator {
  const comparator = item as Comparator;
  return (
    !!comparator.key &&
    (typeof comparator.empty === 'boolean' ||
      typeof comparator.equals !== 'undefined' ||
      typeof comparator.regex === 'string')
  );
}

function isRegexComparator(item: any): item is RegexComparator {
  return 'regex' in item;
}

function validateRegex(regexRef: RegexRef): string[] {
  const errors: string[] = [];

  try {
    // tslint:disable-next-line:no-unused-expression
    new RegExp(regexRef.regex);
  } catch {
    errors.push(`Invalid regex at ${regexRef.path}.regex`);
  }

  if (regexRef.flags) {
    if (!new RegExp('/^[gimsuy]*$/').test(regexRef.flags)) {
      errors.push(`Invalid regex flags at ${regexRef.path}.flags`);
    }
  }

  return errors;
}
