"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateFormDefinition = validateFormDefinition;
exports.validateSection = validateSection;
const ajv_1 = __importDefault(require("ajv"));
const Form_schema_json_1 = __importDefault(require("../schema/Form.schema.json"));
const FormRoot_schema_json_1 = __importDefault(require("../schema/FormRoot.schema.json"));
const Section_1 = require("../Section");
async function validateFormDefinition(form) {
    const errors = [];
    const ajv = new ajv_1.default({ allErrors: true, allowUnionTypes: true });
    if (!ajv.validate(FormRoot_schema_json_1.default, form)) {
        (ajv.errors ?? []).forEach((e) => errors.push(formatAjvError(e)));
    }
    if (Array.isArray(form.sections)) {
        for (let i = 0; i < form.sections.length; i++) {
            const section = form.sections[i];
            errors.push(...await validateSection(section, `sections[${i}]`, ajv));
        }
    }
    if (errors.length === 0) {
        const dataKeys = new Set();
        const unvalidatedDataRefs = [];
        form.sections.forEach((section, sectionIndex) => {
            const sectionDataKeys = new Set();
            const addSectionDataKey = (key) => {
                const dataKey = `${section.key}.${key}`;
                dataKeys.add(dataKey);
                if (sectionDataKeys.has(dataKey)) {
                    errors.push(`data key ${dataKey} is defined more than once`);
                }
                else {
                    sectionDataKeys.add(dataKey);
                }
            };
            if (isFormSection(section)) {
                if (section.properties) {
                    for (const property of section.properties) {
                        addSectionDataKey(property);
                    }
                }
                unvalidatedDataRefs.push(...eachMustacheRef(section, `sections[${sectionIndex}]`));
                let i = 0;
                for (const element of section.elements) {
                    if (element.key) {
                        addSectionDataKey(element.key);
                    }
                    // verify all mustache references are valid (and fully qualified)
                    unvalidatedDataRefs.push(...eachMustacheRef(element, `sections[${sectionIndex}].elements[${i}]`));
                    i++;
                }
            }
            // verify all key references in predicates are valid
            for (const ref of traverseForm(section, `sections[${sectionIndex}]`)) {
                if (isDataRef(ref)) {
                    if (!sectionDataKeys.has(qualifyKey(section, ref.key))) {
                        unvalidatedDataRefs.push(ref);
                    }
                }
                else {
                    errors.push(...validateRegex(ref));
                }
            }
        });
        for (const ref of unvalidatedDataRefs) {
            if (!dataKeys.has(ref.key)) {
                errors.push(`${ref.path} references undefined data key '${ref.key}'`);
            }
        }
    }
    // Deduplicate the error messages
    return errors.filter((e, i) => i === errors.indexOf(e));
}
function isFormSection(section) {
    return (section.type ?? Section_1.SectionType.Form) === Section_1.SectionType.Form;
}
async function validateSection(section, path, ajv) {
    const type = isFormSection(section) ? 'Section' : 'ZedSection';
    // reconfigure the schema to only validate the section
    ajv.validate({
        '$schema': Form_schema_json_1.default.$schema,
        definitions: Form_schema_json_1.default.definitions,
        ...Form_schema_json_1.default.definitions[type]
    }, section);
    return (ajv.errors || [])
        .map((e) => formatAjvError(e, path))
        .filter((e) => !e.includes('"then"'));
}
function formatAjvError(e, basePath) {
    let adjustedDataPath = e.instancePath.length > 0 ?
        e.instancePath
            .substring(1)
            .replace(/\//g, '.').replace(/\.(\d+)/g, '[$1]')
            .replace(/\['([^']+)']/, '.$1') + ' ' : '';
    if (basePath) {
        adjustedDataPath = adjustedDataPath.length > 0 ? `${basePath}.${adjustedDataPath}` : basePath + ' ';
    }
    return `${adjustedDataPath}${e.message?.replace(/\bshould\b/, 'must') ?? ''}`;
}
function* traverseForm(item, path) {
    if (Array.isArray(item)) {
        for (let i = 0; i < item.length; i++) {
            yield* traverseForm(item[i], `${path}[${i}]`);
        }
    }
    else if (typeof item === 'object') {
        if (isComparator(item) && item.key) {
            yield { path, key: item.key };
        }
        for (const key of Object.keys(item)) {
            const val = item[key];
            if (isRegexComparator(item)) {
                yield { path, regex: val, flags: item['flags'] };
            }
            else {
                yield* traverseForm(val, `${path}.${key}`);
            }
        }
    }
}
function* eachMustacheRef(element, path) {
    for (const prop of ['label', 'help', 'text', 'href']) {
        if (element[prop]) {
            const mustacheRegex = /\{\{[#/^>{]?\s*([\w\d_.]+)\s*}}/gi;
            let m;
            do {
                m = mustacheRegex.exec(element[prop]);
                if (m) {
                    yield { path: `${path}.${prop}`, key: m[1] };
                }
            } while (m);
        }
    }
}
function qualifyKey(section, key) {
    return key.startsWith(section.key + '.') ? key : `${section.key}.${key}`;
}
function isDataRef(ref) {
    return 'key' in ref && typeof ref.key === 'string';
}
function isComparator(item) {
    const comparator = item;
    return (!!comparator.key &&
        (typeof comparator.empty === 'boolean' ||
            typeof comparator.equals !== 'undefined' ||
            typeof comparator.regex === 'string'));
}
function isRegexComparator(item) {
    return 'regex' in item;
}
function validateRegex(regexRef) {
    const errors = [];
    try {
        // tslint:disable-next-line:no-unused-expression
        new RegExp(regexRef.regex);
    }
    catch {
        errors.push(`Invalid regex at ${regexRef.path}.regex`);
    }
    if (regexRef.flags) {
        if (!new RegExp('/^[gimsuy]*$/').test(regexRef.flags)) {
            errors.push(`Invalid regex flags at ${regexRef.path}.flags`);
        }
    }
    return errors;
}
//# sourceMappingURL=validateForm.js.map