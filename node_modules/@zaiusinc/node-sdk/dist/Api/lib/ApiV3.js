"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiV3 = void 0;
/* eslint-disable max-classes-per-file */
const node_fetch_1 = __importDefault(require("node-fetch"));
const joinUri_1 = require("./joinUri");
const configure_1 = require("../config/configure");
var ApiV3;
(function (ApiV3) {
    ApiV3.BATCH_LIMIT = 100;
    let ErrorCode;
    (function (ErrorCode) {
        ErrorCode["BatchLimitExceeded"] = "BatchLimitExceeded";
        ErrorCode["Non2xx"] = "Non2xx";
        ErrorCode["Unexpected"] = "Unexpected";
    })(ErrorCode = ApiV3.ErrorCode || (ApiV3.ErrorCode = {}));
    class HttpError extends Error {
        code;
        response;
        constructor(message, code, response) {
            super(message);
            this.code = code;
            this.response = response;
        }
    }
    ApiV3.HttpError = HttpError;
    class API {
        static ERROR_CODE_MESSAGES = {
            [ErrorCode.BatchLimitExceeded]: `A maximum batch size of ${ApiV3.BATCH_LIMIT} is allowed in a single request`,
            [ErrorCode.Non2xx]: 'Http response was outside 2xx',
            [ErrorCode.Unexpected]: 'An unexpected error occurred making the request',
        };
        static DEFAULT_REQUEST_OPTIONS = {
            retry: true,
        };
        /**
         * @hidden backward compatibility
         */
        BATCH_LIMIT = ApiV3.BATCH_LIMIT;
        config;
        constructor(config) {
            if (config) {
                this.config = (0, configure_1.configOrDefault)(config);
            }
        }
        errorForCode = (code) => new HttpError(API.ERROR_CODE_MESSAGES[code], code);
        get = (path) => this.request('GET', path, undefined);
        post = (path, payload) => this.request('POST', path, payload);
        request = (method, path, payload, options = { ...API.DEFAULT_REQUEST_OPTIONS }) => {
            let url = (0, joinUri_1.joinUri)(this.getConfig().apiBasePath, path);
            const body = payload === undefined ? undefined : JSON.stringify(payload);
            return new Promise(async (resolve, reject) => {
                const requestLog = [];
                try {
                    // Allow requests to be monitored or manipulated
                    let requestInfo = { method, headers: this.buildHeaders(), body };
                    const interceptor = this.getConfig().requestInterceptor;
                    if (interceptor) {
                        [url, requestInfo] = interceptor(url, requestInfo);
                    }
                    if (process.env['LOG_REQUESTS'] === 'true') {
                        requestLog.push(`API V3 Request: ${url}`, requestInfo);
                    }
                    const response = await (0, node_fetch_1.default)(url, requestInfo);
                    const { status, statusText, headers } = response;
                    if (status >= 200 && status <= 299) {
                        const data = await response.json();
                        if (process.env['LOG_REQUESTS'] === 'true') {
                            requestLog.push(`(${response.status}) body:`, JSON.stringify(data));
                            console.debug(...requestLog);
                        }
                        const httpResponse = {
                            success: true,
                            data,
                            status,
                            statusText,
                            headers,
                        };
                        resolve(httpResponse);
                    }
                    else {
                        let retryable = false;
                        if (response.status >= 502 && response.status <= 504) {
                            retryable = true;
                        }
                        if (retryable && options.retry) {
                            this.request(method, path, payload, { retry: false }).then((result) => {
                                resolve(result);
                            }, (error) => {
                                reject(error);
                            });
                        }
                        else {
                            const contentType = response?.headers?.get('content-type');
                            const text = await response.text();
                            let data = null;
                            if (contentType?.includes('application/json')) {
                                try {
                                    const json = JSON.parse(text);
                                    data = json;
                                }
                                catch {
                                    // nothing
                                }
                            }
                            if (data == null) {
                                data = { error: text };
                            }
                            const httpResponse = {
                                success: false,
                                data,
                                status,
                                statusText,
                                headers,
                            };
                            const httpError = new HttpError(response.statusText, ErrorCode.Non2xx, httpResponse);
                            if (process.env['LOG_REQUESTS'] === 'true') {
                                requestLog.push(`(${response.status}) body:`, JSON.stringify(httpResponse.data));
                                console.debug(...requestLog);
                            }
                            else {
                                console.error(httpError, JSON.stringify(httpResponse.data));
                            }
                            reject(httpError);
                        }
                    }
                }
                catch (error) {
                    if (process.env['LOG_REQUESTS'] === 'true') {
                        requestLog.push('Unexpected Error:', error.message, error.stack);
                        console.debug(...requestLog);
                    }
                    const httpError = new HttpError(error.message, ErrorCode.Unexpected);
                    httpError.stack = error.stack;
                    reject(httpError);
                }
            });
        };
        getContext = () => this.getConfig().appContext;
        buildHeaders = () => {
            const headersObject = {
                'x-api-key': this.getConfig().apiKey,
                'Content-Type': 'application/json',
            };
            return headersObject;
        };
        getConfig = () => {
            if (this.config) {
                return this.config;
            }
            else {
                return (0, configure_1.getModuleOrGlobalConfig)();
            }
        };
    }
    ApiV3.API = API;
    /**
     * @hidden for backward compatibility
     */
    const moduleScopeApi = new API(null);
    /**
     * @hidden
     * @deprecated for backward compatibility; use odp.v3Api.get instead
     */
    function get(path) {
        return moduleScopeApi.get(path);
    }
    ApiV3.get = get;
    /**
     * @hidden
     * @deprecated for backward compatibility; use odp.v3Api.post instead
     */
    function post(path, payload) {
        return moduleScopeApi.post(path, payload);
    }
    ApiV3.post = post;
})(ApiV3 || (exports.ApiV3 = ApiV3 = {}));
//# sourceMappingURL=ApiV3.js.map