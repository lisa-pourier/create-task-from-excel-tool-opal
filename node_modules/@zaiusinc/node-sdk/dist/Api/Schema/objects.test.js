"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("jest");
const ApiV3_1 = require("../lib/ApiV3");
const ApiObjectExistsError_1 = require("./ApiObjectExistsError");
const ApiObjectNotFoundError_1 = require("./ApiObjectNotFoundError");
const ApiSchemaValidationError_1 = require("./ApiSchemaValidationError");
const objects_1 = require("./objects");
const mockConfiguration = {
    apiBasePath: 'https://api.zaius.com/v3/',
    apiKey: 'api-key'
};
const mockAppConfiguration = {
    apiBasePath: 'https://api.zaius.com/v3/',
    apiKey: 'api-key',
    appContext: {
        app_id: 'test',
        display_name: 'Test App',
        version: '1.0.0',
        vendor: 'optimizely'
    }
};
let apiV3;
describe('objects', () => {
    describe('getObject', () => {
        beforeAll(() => {
            apiV3 = new ApiV3_1.ApiV3.API(mockConfiguration);
        });
        it('sends a get to /schema/objects/{object_name}', async () => {
            const getFn = jest.spyOn(apiV3, 'get').mockResolvedValueOnce({});
            await (0, objects_1.getObject)(apiV3, 'my_object');
            expect(getFn).toHaveBeenCalledWith('/schema/objects/my_object');
            getFn.mockRestore();
        });
        it('throws an error if the api returns an error', async () => {
            const getFn = jest
                .spyOn(apiV3, 'get')
                .mockRejectedValueOnce(new ApiV3_1.ApiV3.HttpError('Gateway Timeout', undefined, {}));
            await expect((0, objects_1.getObject)(apiV3, 'my_object')).rejects.toThrowError('Gateway Timeout');
            getFn.mockRestore();
        });
        it('throws a not found error if the object does not exist', async () => {
            const getFn = jest
                .spyOn(apiV3, 'get')
                .mockRejectedValueOnce(new ApiV3_1.ApiV3.HttpError('Not Found', undefined, { status: 404 }));
            await expect((0, objects_1.getObject)(apiV3, 'my_object')).rejects.toThrowError(ApiObjectNotFoundError_1.ApiObjectNotFoundError);
            getFn.mockRestore();
        });
    });
    describe('getAllObjects', () => {
        beforeAll(() => {
            apiV3 = new ApiV3_1.ApiV3.API(mockConfiguration);
        });
        it('sends a get to /schema/objects', async () => {
            const getFn = jest.spyOn(apiV3, 'get').mockResolvedValueOnce({});
            await (0, objects_1.getAllObjects)(apiV3);
            expect(getFn).toHaveBeenCalledWith('/schema/objects');
            getFn.mockRestore();
        });
        it('throws an error if the api returns an error', async () => {
            const getFn = jest
                .spyOn(apiV3, 'get')
                .mockRejectedValueOnce(new ApiV3_1.ApiV3.HttpError('Access Denied', undefined, {}));
            await expect((0, objects_1.getAllObjects)(apiV3)).rejects.toThrowError('Access Denied');
            getFn.mockRestore();
        });
    });
    describe('createObject', () => {
        beforeAll(() => {
            apiV3 = new ApiV3_1.ApiV3.API(mockConfiguration);
        });
        it('sends a post to /schema/objects', async () => {
            const postFn = jest.spyOn(apiV3, 'post').mockResolvedValueOnce({});
            const object = {
                name: 'my_object',
                display_name: 'My Object',
                fields: [{ name: 'id', display_name: 'ID', type: 'string' }]
            };
            await (0, objects_1.createObject)(apiV3, object);
            expect(postFn).toHaveBeenCalledWith('/schema/objects', object);
            postFn.mockRestore();
        });
        it('throws an error if the api returns an error', async () => {
            const postFn = jest
                .spyOn(apiV3, 'post')
                .mockRejectedValueOnce(new ApiV3_1.ApiV3.HttpError('Bad Request', undefined, {}));
            const object = {
                name: 'my_object',
                display_name: 'My Object',
                fields: [{ name: 'id', display_name: 'ID', type: 'string' }]
            };
            await expect((0, objects_1.createObject)(apiV3, object)).rejects.toThrowError('Bad Request');
            postFn.mockRestore();
        });
        it('throws an exists error if the object already exists', async () => {
            const postFn = jest.spyOn(apiV3, 'post').mockRejectedValueOnce(new ApiV3_1.ApiV3.HttpError('Bad Request', undefined, {
                data: {
                    detail: {
                        invalids: [
                            {
                                field: 'name',
                                reason: 'already used by another object'
                            }
                        ]
                    }
                }
            }));
            const object = {
                name: 'my_object',
                display_name: 'My Object',
                fields: [{ name: 'id', display_name: 'ID', type: 'string' }]
            };
            await expect((0, objects_1.createObject)(apiV3, object)).rejects.toThrowError(ApiObjectExistsError_1.ApiObjectExistsError);
            postFn.mockRestore();
        });
    });
    describe('validateCreateObjects', () => {
        beforeAll(() => {
            apiV3 = new ApiV3_1.ApiV3.API(mockAppConfiguration);
        });
        it('allows objects prefixed with app_id', async () => {
            const postFn = jest.spyOn(apiV3, 'post').mockResolvedValueOnce({});
            const object = {
                name: 'test_my_object',
                display_name: 'Test App My Object',
                fields: [{ name: 'id', display_name: 'ID', type: 'string' }]
            };
            await (0, objects_1.createObject)(apiV3, object);
            expect(postFn).toHaveBeenCalledWith('/schema/objects', object);
            postFn.mockRestore();
        });
        it('throws a validation error if an object is not prefixed with app_id', async () => {
            const object = {
                name: 'other_object',
                display_name: 'Other Object',
                fields: [{ name: 'id', display_name: 'ID', type: 'string' }]
            };
            await expect((0, objects_1.createObject)(apiV3, object)).rejects.toThrowError(ApiSchemaValidationError_1.ApiSchemaValidationError);
        });
        it('throws a validation error if an object alias is not prefixed with app_id', async () => {
            const object = {
                name: 'test_my_object',
                display_name: 'Test App My Object',
                alias: 'my_object',
                fields: [{ name: 'id', display_name: 'ID', type: 'string' }]
            };
            await expect((0, objects_1.createObject)(apiV3, object)).rejects.toThrowError(/object alias.*must be prefixed/);
        });
        it('throws a validation error if an object display name is not prefixed with app display name', async () => {
            const object = {
                name: 'test_my_object',
                display_name: 'My Object',
                fields: [{ name: 'id', display_name: 'ID', type: 'string' }]
            };
            await expect((0, objects_1.createObject)(apiV3, object)).rejects.toThrowError(/object display name.*must be prefixed/);
        });
    });
});
//# sourceMappingURL=objects.test.js.map