"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("jest");
const ApiV3_1 = require("../lib/ApiV3");
const ApiFieldExistsError_1 = require("./ApiFieldExistsError");
const ApiSchemaValidationError_1 = require("./ApiSchemaValidationError");
const fields_1 = require("./fields");
const mockConfiguration = {
    apiBasePath: 'https://api.zaius.com/v3/',
    apiKey: 'api-key'
};
const mockAppConfiguration = {
    apiBasePath: 'https://api.zaius.com/v3/',
    apiKey: 'api-key',
    appContext: {
        app_id: 'test',
        display_name: 'Test App',
        version: '1.0.0',
        vendor: 'optimizely'
    }
};
let apiV3;
describe('fields', () => {
    describe('createField', () => {
        beforeAll(() => {
            apiV3 = new ApiV3_1.ApiV3.API(mockConfiguration);
        });
        it('sends a post to /schema/objects', async () => {
            const postFn = jest.spyOn(apiV3, 'post').mockResolvedValueOnce({});
            const field = { name: 'my_field', display_name: 'My Field', type: 'string' };
            await (0, fields_1.createField)(apiV3, 'my_object', field);
            expect(postFn).toHaveBeenCalledWith('/schema/objects/my_object/fields', field);
            postFn.mockRestore();
        });
        it('throws an error if the api returns an error', async () => {
            const postFn = jest
                .spyOn(apiV3, 'post')
                .mockRejectedValueOnce(new ApiV3_1.ApiV3.HttpError('Bad Request', undefined, {}));
            const field = { name: 'my_field', display_name: 'My Field', type: 'string' };
            await expect((0, fields_1.createField)(apiV3, 'my_object', field)).rejects.toThrowError('Bad Request');
            postFn.mockRestore();
        });
        it('throws an exists error if the field already exists', async () => {
            const postFn = jest.spyOn(apiV3, 'post').mockRejectedValueOnce(new ApiV3_1.ApiV3.HttpError('Bad Request', undefined, {
                data: {
                    detail: {
                        invalids: [
                            {
                                field: 'name',
                                reason: 'already used by another object'
                            }
                        ]
                    }
                }
            }));
            const field = { name: 'my_field', display_name: 'My Field', type: 'string' };
            await expect((0, fields_1.createField)(apiV3, 'my_object', field)).rejects.toThrowError(ApiFieldExistsError_1.ApiFieldExistsError);
            postFn.mockRestore();
        });
    });
    describe('validateCreateFields', () => {
        beforeAll(() => {
            apiV3 = new ApiV3_1.ApiV3.API(mockAppConfiguration);
        });
        it('allows fields prefixed with app_id', async () => {
            const postFn = jest.spyOn(apiV3, 'post').mockResolvedValueOnce({});
            const field = { name: 'test_my_field', display_name: 'Test App My Field', type: 'string' };
            await (0, fields_1.createField)(apiV3, 'my_object', field);
            expect(postFn).toHaveBeenCalledWith('/schema/objects/my_object/fields', field);
            postFn.mockRestore();
        });
        it('throws a validation error if a field is not prefixed with app_id', async () => {
            const field = { name: 'other_field', display_name: 'Other Field', type: 'string' };
            await expect((0, fields_1.createField)(apiV3, 'customers', field)).rejects.toThrowError(ApiSchemaValidationError_1.ApiSchemaValidationError);
        });
        it('throws a validation error if a field display name is not prefixed with app display name', async () => {
            const field = { name: 'test_my_field', display_name: 'My Field', type: 'string' };
            await expect((0, fields_1.createField)(apiV3, 'customers', field)).rejects.toThrowError(/field display name.*must be prefixed/);
        });
    });
});
//# sourceMappingURL=fields.test.js.map