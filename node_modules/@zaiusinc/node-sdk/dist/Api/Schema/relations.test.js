"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("jest");
const ApiV3_1 = require("../lib/ApiV3");
const ApiRelationExistsError_1 = require("./ApiRelationExistsError");
const ApiSchemaValidationError_1 = require("./ApiSchemaValidationError");
const relations_1 = require("./relations");
const mockConfiguration = {
    apiBasePath: 'https://api.zaius.com/v3/',
    apiKey: 'api-key'
};
const mockAppConfiguration = {
    apiBasePath: 'https://api.zaius.com/v3/',
    apiKey: 'api-key',
    appContext: {
        app_id: 'test',
        display_name: 'Test App',
        version: '1.0.0',
        vendor: 'optimizely'
    }
};
let apiV3;
describe('relations', () => {
    describe('createRelation', () => {
        beforeAll(() => {
            apiV3 = new ApiV3_1.ApiV3.API(mockConfiguration);
        });
        it('sends a post to /schema/objects/customers/relations', async () => {
            const postFn = jest.spyOn(apiV3, 'post').mockResolvedValueOnce({});
            const relation = {
                name: 'favorite_product',
                display_name: 'Favorite product',
                child_object: 'products',
                join_fields: [{ parent: 'favorite_product_id', child: 'product_id' }]
            };
            await (0, relations_1.createRelation)(apiV3, 'customers', relation);
            expect(postFn).toHaveBeenCalledWith('/schema/objects/customers/relations', relation);
            postFn.mockRestore();
        });
        it('throws an error if the api returns an error', async () => {
            const postFn = jest
                .spyOn(apiV3, 'post')
                .mockRejectedValueOnce(new ApiV3_1.ApiV3.HttpError('Bad Request', undefined, {}));
            const relation = {
                name: 'favorite_product',
                display_name: 'Favorite product',
                child_object: 'products',
                join_fields: [{ parent: 'favorite_product_id', child: 'product_id' }]
            };
            await expect((0, relations_1.createRelation)(apiV3, 'customers', relation)).rejects.toThrowError('Bad Request');
            postFn.mockRestore();
        });
        it('throws an exists error if the relation already exists', async () => {
            const postFn = jest.spyOn(apiV3, 'post').mockRejectedValueOnce(new ApiV3_1.ApiV3.HttpError('Bad Request', undefined, {
                data: {
                    detail: {
                        invalids: [
                            {
                                field: 'name',
                                reason: 'already used by another relation'
                            }
                        ]
                    }
                }
            }));
            const relation = {
                name: 'favorite_product',
                display_name: 'Favorite product',
                child_object: 'products',
                join_fields: [{ parent: 'favorite_product_id', child: 'product_id' }]
            };
            await expect((0, relations_1.createRelation)(apiV3, 'customers', relation)).rejects.toThrowError(ApiRelationExistsError_1.ApiRelationExistsError);
            postFn.mockRestore();
        });
    });
    describe('validateCreateRelations', () => {
        beforeAll(() => {
            apiV3 = new ApiV3_1.ApiV3.API(mockAppConfiguration);
        });
        it('allows relations without prefixes when the field is not owned by the app', async () => {
            const postFn = jest.spyOn(apiV3, 'post').mockResolvedValueOnce({});
            const relation = {
                name: 'loyalty_tier',
                display_name: 'Loyalty Tier',
                child_object: 'loyalty_tiers',
                join_fields: [{ parent: 'loyalty_tier_id', child: 'id' }]
            };
            await (0, relations_1.createRelation)(apiV3, 'test_profile', relation);
            expect(postFn).toHaveBeenCalledWith('/schema/objects/test_profile/relations', relation);
            postFn.mockRestore();
        });
        it('allows relations prefixed with app_id', async () => {
            const postFn = jest.spyOn(apiV3, 'post').mockResolvedValueOnce({});
            const relation = {
                name: 'test_loyalty_tier',
                display_name: 'Test App Loyalty Tier',
                child_object: 'test_loyalty_tiers',
                join_fields: [{ parent: 'test_loyalty_tier_id', child: 'test_loyalty_tiers' }]
            };
            await (0, relations_1.createRelation)(apiV3, 'customers', relation);
            expect(postFn).toHaveBeenCalledWith('/schema/objects/customers/relations', relation);
            postFn.mockRestore();
        });
        it('throws a validation error if an relation is not prefixed with app_id', async () => {
            const relation = {
                name: 'loyalty_tier',
                display_name: 'Test App Loyalty Tier',
                child_object: 'test_loyalty_tiers',
                join_fields: [{ parent: 'test_loyalty_tier_id', child: 'test_loyalty_tiers' }]
            };
            await expect((0, relations_1.createRelation)(apiV3, 'customers', relation)).rejects.toThrowError(ApiSchemaValidationError_1.ApiSchemaValidationError);
        });
        it('throws a validation error if an relation display name is not prefixed with app display name', async () => {
            const relation = {
                name: 'test_loyalty_tier',
                display_name: 'Loyalty Tier',
                child_object: 'test_loyalty_tiers',
                join_fields: [{ parent: 'test_loyalty_tier_id', child: 'test_loyalty_tiers' }]
            };
            await expect((0, relations_1.createRelation)(apiV3, 'customers', relation)).rejects.toThrowError(/relation display name.*must be prefixed/);
        });
    });
});
//# sourceMappingURL=relations.test.js.map