"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createIdentifier = createIdentifier;
const ApiV3_1 = require("../lib/ApiV3");
const ApiIdentifierExistsError_1 = require("./ApiIdentifierExistsError");
const ApiSchemaValidationError_1 = require("./ApiSchemaValidationError");
const invalidsContain_1 = require("./invalidsContain");
/**
 * Create a customer identifier
 * @param apiV3 the v3 API instance to use
 * @param identifier the identifier to create
 * @throws {ApiIdentifierExistsError} if the identifier already exists
 * @throws {HttpError} if it receives any other non-2XX result
 */
async function createIdentifier(apiV3, identifier) {
    validateCreateIdentifier(identifier, apiV3.getContext());
    try {
        return await apiV3.post('/schema/identifiers', identifier);
    }
    catch (e) {
        if (e instanceof ApiV3_1.ApiV3.HttpError && e.response) {
            const invalids = e.response.data && e.response.data.detail && e.response.data.detail.invalids;
            if ((0, invalidsContain_1.invalidsContain)(invalids, 'customers.name', (reason) => /^already used/.test(reason))) {
                throw new ApiIdentifierExistsError_1.ApiIdentifierExistsError(e);
            }
        }
        throw e;
    }
}
/**
 * @hidden
 * Temporary validation until we update milton
 */
function validateCreateIdentifier(identifier, context) {
    if (context && context.app_id) {
        const prefix = `${context.app_id}_`;
        if (!identifier.name.startsWith(prefix)) {
            throw new ApiSchemaValidationError_1.ApiSchemaValidationError(`identifier name ${identifier.name} must be prefixed with ${prefix}`);
        }
        if (!identifier.display_name.startsWith(context.display_name)) {
            throw new ApiSchemaValidationError_1.ApiSchemaValidationError(`identifier display name ${identifier.display_name} must be prefixed with ${context.display_name}`);
        }
    }
}
//# sourceMappingURL=identifiers.js.map