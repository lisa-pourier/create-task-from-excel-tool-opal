"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRelation = createRelation;
const ApiV3_1 = require("../lib/ApiV3");
const ApiRelationExistsError_1 = require("./ApiRelationExistsError");
const ApiSchemaValidationError_1 = require("./ApiSchemaValidationError");
const invalidsContain_1 = require("./invalidsContain");
/**
 * Create a custom ODP relation between two objects
 * @param apiV3 the v3 API instance to use
 * @param object the object to create the foreign key on
 * @param relation the relation to create
 * @throws {ApiRelationExistsError} if the relation name is already in use by another field or relation
 * @throws {HttpError} if it receives any other non-2XX result
 */
async function createRelation(apiV3, object, relation) {
    validateCreateRelation(relation, apiV3.getContext());
    try {
        return await apiV3.post(`/schema/objects/${object}/relations`, relation);
    }
    catch (e) {
        if (e instanceof ApiV3_1.ApiV3.HttpError && e.response) {
            const invalids = e.response.data && e.response.data.detail && e.response.data.detail.invalids;
            if ((0, invalidsContain_1.invalidsContain)(invalids, 'name', (reason) => /^already used/.test(reason))) {
                throw new ApiRelationExistsError_1.ApiRelationExistsError(e);
            }
        }
        throw e;
    }
}
/**
 * @hidden
 * Temporary validation until we update milton
 */
function validateCreateRelation(relation, context) {
    if (context && context.app_id) {
        const prefix = `${context.app_id}_`;
        if (relation.join_fields.find((joinField) => joinField.parent.startsWith(prefix))) {
            if (!relation.name.startsWith(prefix)) {
                throw new ApiSchemaValidationError_1.ApiSchemaValidationError(`relation name ${relation.name} must be prefixed with ${prefix}`);
            }
            if (!relation.display_name.startsWith(context.display_name)) {
                throw new ApiSchemaValidationError_1.ApiSchemaValidationError(`relation display name ${relation.display_name} must be prefixed with ${context.display_name}`);
            }
        }
    }
}
//# sourceMappingURL=relations.js.map