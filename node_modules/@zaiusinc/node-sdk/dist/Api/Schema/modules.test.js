"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("jest");
const ApiV3_1 = require("../lib/ApiV3");
const ApiModuleAlreadyEnabledError_1 = require("./ApiModuleAlreadyEnabledError");
const modules_1 = require("./modules");
const mockConfiguration = {
    apiBasePath: 'https://api.zaius.com/v3/',
    apiKey: 'api-key'
};
const mockAppConfiguration = {
    apiBasePath: 'https://api.zaius.com/v3/',
    apiKey: 'api-key',
    appContext: {
        app_id: 'test',
        display_name: 'Test App',
        version: '1.0.0',
        vendor: 'optimizely'
    }
};
let apiV3;
describe('modules', () => {
    describe('getEnabledModules', () => {
        beforeAll(() => {
            apiV3 = new ApiV3_1.ApiV3.API(mockConfiguration);
        });
        it('sends a get to /schema/modules', async () => {
            const getFn = jest.spyOn(apiV3, 'get').mockResolvedValueOnce({});
            await (0, modules_1.getEnabledModules)(apiV3);
            expect(getFn).toHaveBeenCalledWith('/schema/modules');
            getFn.mockRestore();
        });
        it('throws an error if the api returns an error', async () => {
            const getFn = jest
                .spyOn(apiV3, 'get')
                .mockRejectedValueOnce(new ApiV3_1.ApiV3.HttpError("I'm a teapot", undefined, {}));
            await expect((0, modules_1.getEnabledModules)(apiV3)).rejects.toThrowError("I'm a teapot");
            getFn.mockRestore();
        });
    });
    describe('enableModule', () => {
        beforeAll(() => {
            apiV3 = new ApiV3_1.ApiV3.API(mockAppConfiguration);
        });
        it('sends a post to /schema/modules', async () => {
            const postFn = jest.spyOn(apiV3, 'post').mockResolvedValueOnce({});
            await (0, modules_1.enableModule)(apiV3, 'foo');
            expect(postFn).toHaveBeenCalledWith('/schema/modules', { module: 'foo' });
            postFn.mockRestore();
        });
        it('throws an error if the api returns an error', async () => {
            const postFn = jest
                .spyOn(apiV3, 'post')
                .mockRejectedValueOnce(new ApiV3_1.ApiV3.HttpError('Bad Request', undefined, {}));
            await expect((0, modules_1.enableModule)(apiV3, 'foo')).rejects.toThrowError('Bad Request');
            postFn.mockRestore();
        });
        it('throws an already enabled error if the module is already enabled', async () => {
            const postFn = jest.spyOn(apiV3, 'post').mockRejectedValueOnce(new ApiV3_1.ApiV3.HttpError('Bad Request', undefined, {
                data: {
                    detail: {
                        invalids: [
                            {
                                field: 'module',
                                reason: 'already enabled'
                            }
                        ]
                    }
                }
            }));
            await expect((0, modules_1.enableModule)(apiV3, 'foo')).rejects.toThrowError(ApiModuleAlreadyEnabledError_1.ApiModuleAlreadyEnabledError);
            postFn.mockRestore();
        });
    });
});
//# sourceMappingURL=modules.test.js.map